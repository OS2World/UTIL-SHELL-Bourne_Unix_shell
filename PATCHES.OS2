Only in os2/SRC: dir.c
Only in os2/SRC: dir.h
Only in os2/SRC: isfat.c
Only in os2/SRC: jobs.c
Only in os2/SRC: sh.cs
Only in os2/SRC: sh.def
diff -cbBwr orig/SRC/sh.h os2/SRC/sh.h
*** orig/SRC/sh.h	Wed Feb 20 21:24:34 1991
--- os2/SRC/sh.h	Wed Feb 20 20:36:22 1991
***************
*** 96,102 ****
  #define HISTORY_MAX	100	/* History array length			*/
  				/* Space for full file name		*/
  #define FFNAME_MAX	(PATH_MAX + NAME_MAX + 4)
! #define CMD_LINE_MAX	127	/* Max command line length		*/
  #define SSAVE_IO_SIZE	4	/* Save IO array malloc increment	*/
  
  #define	NPUSH		8	/* limit to input nesting		*/
--- 96,102 ----
  #define HISTORY_MAX	100	/* History array length			*/
  				/* Space for full file name		*/
  #define FFNAME_MAX	(PATH_MAX + NAME_MAX + 4)
! #define CMD_LINE_MAX	2048	/* Max command line length		*/
  #define SSAVE_IO_SIZE	4	/* Save IO array malloc increment	*/
  
  #define	NPUSH		8	/* limit to input nesting		*/
***************
*** 109,114 ****
--- 109,116 ----
  #define SP		' '
  #define	NOT		'^'
  
+ #define BATCHEXT        ".cmd"
+ 
  /* Here we introduce a new boolean value - MAYBE.  This is required for
   * a special case of the grave function
   */
***************
*** 190,235 ****
  
  #define	FEXEC		0x0001	/* execute without forking		*/
  
- /* MSDOS Memory Control Block chain structure */
- 
- #pragma pack (1)
- struct MCB_list	{
-     char		MCB_type;	/* M or Z			*/
-     unsigned int	MCB_pid;	/* Process ID			*/
-     unsigned int	MCB_len;	/* MCB length			*/
- };
- #pragma pack ()
- 
- #define MCB_CON		'M'		/* More MCB's			*/
- #define MCB_END		'Z'		/* Last MCB's			*/
- 
- /* Externs for Swapper assembler function */
- 
- extern char		cmd_line[];	/* Command line			*/
- extern char		path_line[];	/* Process path			*/
  extern unsigned int	SW_intr;	/* interrupt pending		*/
- extern unsigned int	SW_Blocks;	/* Number of blocks to read	*/
- extern unsigned int	SW_SBlocks;	/* Short Number of blocks to	*/
- 					/* read				*/
- extern int		SW_fp;		/* File or EMS Handler		*/
- extern int		SW_Pwrite;	/* Partial write to disk?	*/
- extern unsigned long	SW_EMstart;	/* Start addr of extend mem	*/
- extern unsigned int	SW_Mode;	/* Type of swapping to do	*/
- 					/* 1 - disk			*/
- 					/* 2 - Extended	memory		*/
- 					/* 3 - EMS Driver		*/
- 					/* 4 - XMS Driver		*/
- extern unsigned int	SW_EMSFrame;	/* EMS Frame segment		*/
- 
- extern unsigned int	etext;		/* End of text segment		*/
- extern int		Swap_Mode;	/* Swapping mode		*/
- 
- /* If you change these values, change sh7, swap_device as well */
- 
- #define SWAP_OFF	0x0000		/* No swapping			*/
- #define SWAP_DISK	0x0001		/* Disk only			*/
- #define SWAP_EXTEND	0x0002		/* Extended memory		*/
- #define SWAP_EXPAND	0x0004		/* Expanded memory		*/
  
  /*
   * flags to control evaluation of words
--- 192,198 ----
***************
*** 651,673 ****
  extern void	Clear_Extended_File (void);
  extern void	Print_Version (int);
  extern bool	anys (char *, char *);
- extern void	Clear_Swap_File (void);
  extern C_Op	*Copy_Function (C_Op *);
  extern void	Convert_Backslashes (char *);
- 
- /*
-  * Interrupt handling
-  */
- 
- extern void interrupt	SW_Int24 (void);	/* Int 24 New address	*/
- extern void (interrupt far *SW_I0_V) (void);	/* Int 0 address	*/
- extern void (interrupt far *SW_I23_V) (void);	/* Int 23 address	*/
- 
- /*
-  * XMS Driver functions
-  */
- 
- extern void (far *SW_XMS_Driver) (void);	/* XMS Driver Interface	*/
- extern int		SW_XMS_Gversion (void);
- extern int		SW_XMS_Allocate (unsigned int);
- extern int		SW_XMS_Free (int);
--- 614,618 ----
diff -cbBwr orig/SRC/sh1.c os2/SRC/sh1.c
*** orig/SRC/sh1.c	Wed Feb 20 21:24:52 1991
--- os2/SRC/sh1.c	Wed Feb 20 21:05:12 1991
***************
*** 93,103 ****
  #include <ctype.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dirent.h>
  #include <dos.h>
  #include <time.h>
  #include "sh.h"
  
  /*
   * Structure of Malloced space to allow release of space nolonger required
   * without having to know about it.
--- 93,108 ----
  #include <ctype.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dir.h>
  #include <dos.h>
  #include <time.h>
  #include "sh.h"
  
+ #define INCL_NOPM
+ #define INCL_DOSPROCESS
+ #define INCL_DOSERRORS
+ #include <os2.h>
+ 
  /*
   * Structure of Malloced space to allow release of space nolonger required
   * without having to know about it.
***************
*** 136,143 ****
  static char	*Path	   = "PATH";
  				/* Entry directory			*/
  static char	*Start_directory = (char *)NULL;
- 					/* Original Interrupt 24 address */
- static void	(interrupt far *Orig_I24_V) (void);
  #ifdef SIGQUIT
  static void	(*qflag)(int) = SIG_IGN;
  #endif
--- 141,146 ----
***************
*** 154,159 ****
--- 157,165 ----
  static void	Load_G_VL (void);
  static void	Load_profiles (void);
  static void	U2D_Path (void);
+ static void     dowaits(int);
+ 
+ unsigned int SW_intr;
  
  /*
   * The main program starts here
***************
*** 333,338 ****
--- 339,346 ----
  	}
  
  	onecommand ();
+ 
+         dowaits(0);  /* wait for ending async. processes */
      }
  }
  
***************
*** 486,491 ****
--- 494,550 ----
      }
  }
  
+ 
+ /*
+  * look for any ending childs
+  */
+ 
+ static void dowaits(int mode)
+ {
+   RESULTCODES rc;
+   PID pid;
+   char buffer[32];
+   USHORT res;
+   USHORT wmode = DCWW_NOWAIT;
+ 
+   for (;;)
+   {
+     res = DosCwait(DCWA_PROCESS, wmode, &rc, &pid, 0);
+ 
+     if ( mode && (res == ERROR_CHILD_NOT_COMPLETE) )
+     {
+       S_puts("(Waiting for childs)\n");
+       wmode = DCWW_WAIT;
+       continue;
+     }
+     else
+       if ( res )
+         break;
+ 
+     sprintf(buffer, "[%u] ", pid);
+     S_puts(buffer);
+ 
+     switch (rc.codeTerminate)
+     {
+     case TC_EXIT:
+       sprintf(buffer, "Done (%u)\n", rc.codeResult);
+       S_puts(buffer);
+       break;
+     case TC_HARDERROR:
+       S_puts("Terminated\n");
+       break;
+     case TC_TRAP:
+       sprintf(buffer, "Trap %d\n", rc.codeResult);
+       S_puts(buffer);
+       break;
+     case TC_KILLPROCESS:
+       S_puts("Killed\n");
+       break;
+     }
+   }
+ }
+ 
+ 
  /*
   * Terminate current environment with an error
   */
***************
*** 506,516 ****
--- 565,577 ----
      if (execflg)
  	fail ();
  
+ #if 0
      if (Orig_I24_V == (void (far *)())NULL)
      {
  	S_puts ("sh: ignoring attempt to leave lowest level shell\n");
  	fail ();
      }
+ #endif
  
  /* Clean up */
  
***************
*** 521,526 ****
--- 582,591 ----
  
      runtrap (0);
  
+ /* wait for running bg processes */
+ 
+     dowaits(1);
+ 
  /* Dump history on exit */
  
  #ifndef NO_HISTORY
***************
*** 530,539 ****
  
      closeall ();
  
- /* Clear swap file if necessary */
- 
-     Clear_Swap_File ();
- 
  /* If this is a command only - restore the directory because DOS doesn't
   * and the user might expect it
   */
--- 595,600 ----
***************
*** 552,558 ****
   * Output warning message
   */
  
! void	print_warn (fmt)
  char	*fmt;
  {
      va_list	ap;
--- 613,619 ----
   * Output warning message
   */
  
! void	print_warn (fmt, ...)
  char	*fmt;
  {
      va_list	ap;
***************
*** 573,579 ****
   * Output error message
   */
  
! void	print_error (fmt)
  char	*fmt;
  {
      va_list	ap;
--- 634,640 ----
   * Output error message
   */
  
! void	print_error (fmt, ...)
  char	*fmt;
  {
      va_list	ap;
***************
*** 719,729 ****
      signal (SIGINT, onintr);
      SW_intr = 1;
  
- /* Zap the swap file, just in case it got corrupted */
- 
-     S_close (SW_fp, TRUE);
-     Clear_Swap_File ();
- 
  /* Are we talking to the user?  Yes - check in parser */
  
      if (talking)
--- 780,785 ----
***************
*** 766,771 ****
--- 822,828 ----
  
  char		*strsave (s, a)
  register char	*s;
+ int a;
  {
      register char	*cp;
  
***************
*** 788,798 ****
      if (i == SIGINT)		/* Need this because swapper sets it	*/
      {
  	SW_intr = 0;
- 
- /* Zap the swap file, just in case it got corrupted */
- 
- 	S_close (SW_fp, TRUE);
- 	Clear_Swap_File ();
      }
  
      trapset = i;
--- 845,850 ----
***************
*** 1569,1583 ****
  void	put_prompt (s)
  char	*s;
  {
!     struct dosdate_t 	d_date;
!     struct dostime_t	d_time;
      int	i;
      char buf[PATH_MAX + 4];
  
      last_prompt = s;		/* Save the Last prompt output		*/
  
!     _dos_gettime (&d_time);	/* Get the date and time in case	*/
!     _dos_getdate (&d_date);
  
      while (*s)
      {
--- 1621,1635 ----
  void	put_prompt (s)
  char	*s;
  {
!     time_t ti;
!     struct tm *tl;
      int	i;
      char buf[PATH_MAX + 4];
  
      last_prompt = s;		/* Save the Last prompt output		*/
  
!     time(&ti);
!     tl = localtime(&ti);
  
      while (*s)
      {
***************
*** 1605,1617 ****
  			break;
  
  		    case 't':		    /* time	    */
! 			sprintf (buf,"%.2d:%.2d", d_time.hour, d_time.minute);
  			break;
  
  		    case 'd':		    /* date	    */
  			sprintf (buf, "%.3s %.2d-%.2d-%.2d",
! 				 &"SunMonTueWedThuFriSat"[d_date.dayofweek * 3],
! 				 d_date.day, d_date.month, d_date.year % 100);
  			break;
  
  		    case 'p':		    /* directory    */
--- 1657,1669 ----
  			break;
  
  		    case 't':		    /* time	    */
! 			sprintf (buf,"%.2d:%.2d", tl -> tm_hour, tl -> tm_min);
  			break;
  
  		    case 'd':		    /* date	    */
  			sprintf (buf, "%.3s %.2d-%.2d-%.2d",
! 				 &"SunMonTueWedThuFriSat"[tl -> tm_wday * 3],
! 				 tl -> tm_mday, tl -> tm_mon, tl -> tm_year % 100);
  			break;
  
  		    case 'p':		    /* directory    */
***************
*** 1624,1630 ****
  			break;
  
  		    case 'v':		    /* version	    */
! 			sprintf (buf, "MS-DOS %.2d:%.2d", _osmajor, _osminor);
  			break;
  		}
  
--- 1676,1682 ----
  			break;
  
  		    case 'v':		    /* version	    */
! 			sprintf (buf, "%.2d.%.2d", _osmajor, _osminor);
  			break;
  		}
  
***************
*** 1682,1688 ****
  {
      register char	*s, *s1;
      char		**ap;
!     Var_List		*lset;
      bool		l_rflag = FALSE;
  
  /* Patch the ctype table as a cheat */
--- 1734,1740 ----
  {
      register char	*s, *s1;
      char		**ap;
!     Var_List		*lset, *init;
      bool		l_rflag = FALSE;
  
  /* Patch the ctype table as a cheat */
***************
*** 1693,1701 ****
   * address
   */
  
-     Orig_I24_V = _dos_getvect (0x24);
-     _dos_setvect (0x24, SW_Int24);
- 
  /* Load the environment into our structures */
  
      if ((ap = environ) != (char **)NULL)
--- 1745,1750 ----
***************
*** 1772,1777 ****
--- 1821,1829 ----
  /* Set up home directory */
  
      if ((lset = lookup (home, TRUE))->value == null)
+       if ((init = lookup ("INIT", TRUE))->value != null)
+ 	setval (lset, init->value);
+       else
  	setval (lset, C_dir->value);
  
      s_vstatus (lset, EXPORT);
***************
*** 1793,1799 ****
  	setval (ifs, " \t\n");
  
      if (ps1->value == null)
! 	setval (ps1, "$ ");
  
      if (ps2->value == null)
  	setval (ps2, "> ");
--- 1845,1851 ----
  	setval (ifs, " \t\n");
  
      if (ps1->value == null)
! 	setval (ps1, "%e$ ");
  
      if (ps2->value == null)
  	setval (ps2, "> ");
***************
*** 1895,1902 ****
  static void	Pre_Process_Argv (argv)
  char		**argv;
  {
!     char	*ocl = (char far *)((((long)_psp) << 16) + 0x081L);
  
  
  /* Check for these options */
  
--- 1947,1957 ----
  static void	Pre_Process_Argv (argv)
  char		**argv;
  {
!     extern      char far *_pgmptr;
!     char	*ocl = _pgmptr;
  
+     ocl = strchr(ocl, 0) + 1;
+     ocl = strchr(ocl, 0) + 1;
  
  /* Check for these options */
  
***************
*** 1964,1969 ****
--- 2019,2025 ----
  {
      char	*name;
      int		f;
+     char        prof[128], *env;
  
  /* Set up home profile */
  
***************
*** 1982,1987 ****
--- 2038,2057 ----
      {
  	PUSHIO (afile, remap (f), filechar);
      }
+ 
+     if ( (env = getenv("INIT")) != NULL )
+       if ((f = O_for_execute (strcat(strcpy(prof, env), "/profile"),
+                               (char **)NULL, (int *)NULL)) >= 0)
+       {
+           PUSHIO (afile, remap (f), filechar);
+       }
+ 
+     if ( (env = getenv("HOME")) != NULL )
+       if ((f = O_for_execute (strcat(strcpy(prof, env), "/profile"),
+                               (char **)NULL, (int *)NULL)) >= 0)
+       {
+           PUSHIO (afile, remap (f), filechar);
+       }
  }
  
  /*
diff -cbBwr orig/SRC/sh10.c os2/SRC/sh10.c
*** orig/SRC/sh10.c	Wed Feb 20 21:25:34 1991
--- os2/SRC/sh10.c	Wed Feb 20 20:22:46 1991
***************
*** 37,43 ****
  #include <sys/stat.h>
  #include <stdio.h>
  #include <process.h>
- #include <dos.h>
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
--- 37,42 ----
***************
*** 47,53 ****
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dirent.h>
  #include "sh.h"
  
  
--- 46,52 ----
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dir.h>
  #include "sh.h"
  
  
diff -cbBwr orig/SRC/sh2.c os2/SRC/sh2.c
*** orig/SRC/sh2.c	Wed Feb 20 21:25:20 1991
--- os2/SRC/sh2.c	Wed Feb 20 20:22:32 1991
***************
*** 42,47 ****
--- 42,48 ----
  
  #include <sys/types.h>
  #include <stddef.h>
+ #include <stdio.h>
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
***************
*** 49,55 ****
  #include <ctype.h>
  #include <unistd.h>
  #include <limits.h>
! #include <dirent.h>
  #include "sh.h"
  
  /*
--- 50,56 ----
  #include <ctype.h>
  #include <unistd.h>
  #include <limits.h>
! #include <dir.h>
  #include "sh.h"
  
  /*
***************
*** 557,562 ****
--- 558,564 ----
  }
  
  static C_Op	*block (type, t1, t2, wp)
+ int             type;
  C_Op		*t1, *t2;
  char		**wp;
  {
diff -cbBwr orig/SRC/sh3.c os2/SRC/sh3.c
*** orig/SRC/sh3.c	Wed Feb 20 21:25:00 1991
--- os2/SRC/sh3.c	Wed Feb 20 20:58:50 1991
***************
*** 115,121 ****
  #include <sys/stat.h>
  #include <stdio.h>
  #include <process.h>
- #include <dos.h>
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
--- 115,120 ----
***************
*** 125,135 ****
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dirent.h>
  #include <ctype.h>
  
  #include "sh.h"
  
  /* static Function and string declarations */
  
  static int	forkexec (C_Op *, int, int, int, char **);
--- 124,138 ----
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dir.h>
  #include <ctype.h>
  
  #include "sh.h"
  
+ #define INCL_NOPM
+ #define INCL_DOS
+ #include <os2.h>
+ 
  /* static Function and string declarations */
  
  static int	forkexec (C_Op *, int, int, int, char **);
***************
*** 140,151 ****
  static int	rexecve (char *, char **, char **, bool);
  static int	Execute_program (char *, char **, char **, bool);
  static int	S_spawnve (char *, char **, char **);
- static bool	Get_EMS_Driver (void);
- static bool	Get_XMS_Driver (void);
- static bool	EMS_error (char *, int);
- static int	EMS_Close (void);
- static bool	XMS_error (char *, int);
- static int	XMS_Close (void);
  static int	build_command_line (char *, char **, char **);
  static int	setstatus (int);
  static bool	Check_for_bat_file (char *);
--- 143,148 ----
***************
*** 152,164 ****
  static size_t	white_space_len (char *, bool *);
  static char	*Gen_Full_Path_Name (char *);
  
  static char	*AE2big = "arg/env list too big";
- static char	*EMS_emsg = "Warning: EMS Error (%x)\n";
- static char	*XMS_emsg = "Warning: XMS Error (%x)\n";
  static char	*EF_msg = "%s: %s\n";
  			/* Extended Command line processing file name	*/
  static char		*Extend_file = (char *)NULL;
- static char		*Swap_File = (char *)NULL;	/* Swap file	*/
  
  /*
   * execute tree recursively
--- 149,160 ----
  static size_t	white_space_len (char *, bool *);
  static char	*Gen_Full_Path_Name (char *);
  
+ static int      spawnmode = P_WAIT;
+ 
  static char	*AE2big = "arg/env list too big";
  static char	*EF_msg = "%s: %s\n";
  			/* Extended Command line processing file name	*/
  static char		*Extend_file = (char *)NULL;
  
  /*
   * execute tree recursively
***************
*** 182,187 ****
--- 178,184 ----
      int			Local_depth;		/* Save local values	*/
      int			Local_areanum;
      int			rv = 0;
+     int                 readp, writep;
  
  /* End of tree ? */
  
***************
*** 253,270 ****
  	    break;
  
  	case TPIPE:			/* Pipe processing		*/
- 	    if ((rv = openpipe ()) < 0)
- 		break;
  
  /* Create pipe, execute command, reset pipe, execute the other side, close
   * the pipe and fini
   */
! 
  	    localpipe = remap (rv);
  	    execute (t->left, pin, localpipe, 0);
  	    lseek (localpipe, 0L, SEEK_SET);
  	    rv = execute (t->right, localpipe, pout, 0);
  	    closepipe (localpipe);
  	    break;
  
  	case TLIST:			/* Entries in a for statement	*/
--- 250,298 ----
  	    break;
  
  	case TPIPE:			/* Pipe processing		*/
  
  /* Create pipe, execute command, reset pipe, execute the other side, close
   * the pipe and fini
   */
! 	 /* old DOS version:
!             if ((rv = openpipe ()) < 0)
! 		break;
  	    localpipe = remap (rv);
  	    execute (t->left, pin, localpipe, 0);
  	    lseek (localpipe, 0L, SEEK_SET);
  	    rv = execute (t->right, localpipe, pout, 0);
  	    closepipe (localpipe);
+          */
+ 
+             if (DosMakePipe((PHFILE) &readp, (PHFILE) &writep, 0))
+                 break;
+ 	    readp = remap (readp);
+ 	    writep = remap (writep);
+             DosSetFHandState(readp, OPEN_FLAGS_NOINHERIT);
+ 	    DosSetFHandState(writep, OPEN_FLAGS_NOINHERIT);
+ 
+             if ( spawnmode == P_WAIT )
+             {
+               spawnmode = P_NOWAITO;
+ 	      execute (t->left, pin, writep, 0);
+               close(writep);
+               spawnmode = P_NOWAIT;
+ 	      rv = execute (t->right, readp, pout, 0);
+               close(readp);
+               spawnmode = P_WAIT;
+               cwait(&rv, rv, WAIT_GRANDCHILD);
+             }
+             else
+             {
+               rv = spawnmode;
+               spawnmode = P_NOWAITO;
+ 	      execute (t->left, pin, writep, 0);
+               close(writep);
+               spawnmode = rv;
+ 	      rv = execute (t->right, readp, pout, 0);
+               close(readp);
+             }
+ 
  	    break;
  
  	case TLIST:			/* Entries in a for statement	*/
***************
*** 272,281 ****
  	    rv = execute (t->right, pin, pout, 0);
  	    break;
  
! 	case TASYNC:			/* Async - not supported	*/
! 	    rv = -1;
  	    S_puts ("sh: Async commands not supported\n");
  	    setstatus (rv);
  	    break;
  
  	case TOR:			/* || and &&			*/
--- 300,317 ----
  	    rv = execute (t->right, pin, pout, 0);
  	    break;
  
! 	case TASYNC:
! 	 /* rv = -1;
  	    S_puts ("sh: Async commands not supported\n");
  	    setstatus (rv);
+          */
+             spawnmode = P_NOWAIT;
+ 	    rv = execute (t->left, pin, pout, 0);
+             spawnmode = P_WAIT;
+             S_puts("[");
+             S_puts(putn(rv));
+             S_puts("]\n");
+             setval (lookup ("!", TRUE), putn (rv));
  	    break;
  
  	case TOR:			/* || and &&			*/
***************
*** 458,464 ****
  {
      unsigned int	dummy;
  
!     _dos_setdrive (tolower(*path) - 'a' + 1, &dummy);
  
      if (chdir (&path[2]) != 0)
      {
--- 494,500 ----
  {
      unsigned int	dummy;
  
!     DosSelectDisk(tolower(*path) - 'a' + 1);
  
      if (chdir (&path[2]) != 0)
      {
***************
*** 523,529 ****
  
  /* Check for built in commands */
  
! 	else if (cp != (char *)NULL)
  	    shcom = inbuilt (cp, &builtin);
      }
  
--- 559,566 ----
  
  /* Check for built in commands */
  
! 	else
!           if (cp != (char *)NULL)
  	    shcom = inbuilt (cp, &builtin);
      }
  
***************
*** 531,536 ****
--- 568,574 ----
  
      t->words = wp;
      if ((act & FEXEC) == 0)
+     if (shcom == NULL && (act & FEXEC) == 0)
      {
  	spawn = TRUE;
  
***************
*** 911,918 ****
      int			nargc = 0;		/* # script args	*/
      char		*p_name;		/* Program name		*/
      int			i;
!     union REGS		r;
  
  /* If the environment is null - It is too big - error */
  
      if (envp == (char **)NULL)
--- 949,963 ----
      int			nargc = 0;		/* # script args	*/
      char		*p_name;		/* Program name		*/
      int			i;
! 
! /* Count the number of arguments to the program in case of shell script or
!  * bat file
!  */
! 
!     while (v[argc++] != (char *)NULL);
  
+     ++argc;				/* Including the null		*/
+ 
  /* If the environment is null - It is too big - error */
  
      if (envp == (char **)NULL)
***************
*** 921,937 ****
      else if ((p_name = getcell (FFNAME_MAX)) == (char *)NULL)
  	em = strerror (ENOMEM);
  
!     else
      {
! 
! /* Count the number of arguments to the program in case of shell script or
!  * bat file
!  */
  
! 	while (v[argc++] != (char *)NULL);
! 
! 	++argc;				/* Including the null		*/
  
  /* Start off on the search path for the executable file */
  
  	sp = (any ('/', c) || (*(c + 1) == ':')) ? null : path->value;
--- 966,991 ----
      else if ((p_name = getcell (FFNAME_MAX)) == (char *)NULL)
  	em = strerror (ENOMEM);
  
!     else if ( c == NULL )
      {
! /* cmd.exe interal command */
  
!       if ((new_argv = (char **) getcell (sizeof(char *) * (argc + 2)))
!  	      == NULL)
!   	em = strerror (ENOMEM);
!       else
!       {
!         memcpy (&new_argv[2], &v[0], sizeof(char *) * argc);
!         new_argv[0] = lookup ("COMSPEC", FALSE)->value;
!         new_argv[1] = "/c";
!         res = rexecve (new_argv[0], new_argv, envp, d_flag);
!         DELETE (new_argv);
! 	return res;
!       }
!     }
  
+     else
+     {
  /* Start off on the search path for the executable file */
  
  	sp = (any ('/', c) || (*(c + 1) == ':')) ? null : path->value;
***************
*** 992,1005 ****
  		    {
  			new_argv[0] = lookup ("COMSPEC", FALSE)->value;
  			new_argv[1] = "/c";
- 
- /* Get the switch character */
- 
- 			r.x.ax = 0x3700;
- 			intdos (&r, &r);
- 
- 			if ((r.h.al == 0) && (_osmajor < 4))
- 			    *new_argv[1] = (char)(r.h.dl);
  		    }
  
  /* Stick in the pre-fix arguments */
--- 1046,1051 ----
***************
*** 1102,1110 ****
  	++cp;
  
      if ((cp = strrchr (cp, '.')) == (char *)NULL)
! 	strcat (local_path, ".bat");
  
!     else if (stricmp (cp, ".bat") != 0)
      {
  	DELETE (local_path);
  	return FALSE;
--- 1148,1156 ----
  	++cp;
  
      if ((cp = strrchr (cp, '.')) == (char *)NULL)
! 	strcat (local_path, BATCHEXT);
  
!     else if (stricmp (cp, BATCHEXT) != 0)
      {
  	DELETE (local_path);
  	return FALSE;
***************
*** 1215,1225 ****
  char		**parms;
  char		**envp;
  {
!     unsigned int	c_cur = (unsigned int)(_psp - 1);
!     unsigned int	size = 0;
!     char		*ep, *ep1;
      int			res, serrno;
-     struct MCB_list	*mp = (struct MCB_list *)((unsigned long)c_cur << 16L);
  
  /* Check to see if the file exists */
  
--- 1261,1268 ----
  char		**parms;
  char		**envp;
  {
!     char		*ep, *ep1, path_line[255];
      int			res, serrno;
  
  /* Check to see if the file exists */
  
***************
*** 1256,1636 ****
      else if (access (path_line, F_OK) != 0)
  	return -1;
  
! /* Process the command line.  If no swapping, we have executed the program */
! 
!     res = build_command_line (path_line, parms, envp);
! 
!     if ((Swap_Mode == SWAP_OFF) || res)
! 	return res;
! 
! /* Find the length of the swap area */
! 
!     while ((mp = (struct MCB_list *)((unsigned long)c_cur << 16L))->MCB_type
! 	    == MCB_CON)
!     {
! 	if ((mp->MCB_pid != _psp) && (mp->MCB_pid != 0) &&
! 	    (mp->MCB_type != MCB_END))
! 	{
! 	    Clear_Extended_File ();
! 	    print_error ("Fatal: Memory chain corrupt\n");
! 	    return -1;
! 	}
! 
! 	c_cur += (mp->MCB_len + 1);
! 	size += mp->MCB_len + 1;
!     }
! 
! /*
!  * Convert swap size from paragraphs to 16K blocks.
!  */
! 
!     if (size == 0)
! 	size = mp->MCB_len + 1;
! 
!     SW_Blocks = (size / 0x0400) + 1;
!     SW_SBlocks = ((size - etext + _psp - 1) / 0x0400) + 1;
! 
! /* OK Now we've set up the FCB's, command line and opened the swap file.
!  * Get some sys info for the swapper and execute my little assembler
!  * function to swap us out
!  */
! 
! /* Save the interrupt 0 and 23 addresses */
! 
!     SW_I0_V  = _dos_getvect (0x00);
!     SW_I23_V = _dos_getvect (0x23);
! 
! /* Ok - 3 methods of swapping */
! 
! /* If expanded memory - try that */
! 
!     if ((Swap_Mode & SWAP_EXPAND) && Get_EMS_Driver ())
!     {
! 	int	cr;
! 
! 	SW_Mode = 3;			/* Set Expanded memory swap	*/
! 
! 	res = SA_spawn (envp);
! 	cr = EMS_Close ();		/* Close EMS			*/
! 
! 	if ((res != -2) && cr)		/* Report Close error ?		*/
! 	{
! 	    res = -2;
! 	    errno = cr;
! 	}
! 
! 	if (res == -2)
! 	    EMS_error ("Expanded memory swap failed (%x)\n", errno);
! 
! 	else
! 	{
! 	    Clear_Extended_File ();
! 	    return res;
! 	}
! 
! /* Failed - disabled */
! 
! 	Swap_Mode &= (~SWAP_EXPAND);
!     }
! 
!     if ((Swap_Mode & SWAP_EXTEND) && Get_XMS_Driver ())
!     {
! 	int	cr;
! 
! /* Set Extended memory or XMS driver */
! 
! 	SW_Mode = (SW_fp == -1) ? 2 : 4;
! 
! 	res = SA_spawn (envp);
! 	cr = XMS_Close ();		/* Close XMS			*/
! 
! 	if ((res != -2) && cr)		/* Report Close error ?		*/
! 	{
! 	    res = -2;
! 	    errno = cr;
! 	}
! 
! 	if (res == -2)
! 	    XMS_error ("Extended memory swap failed (%x)\n", errno);
! 
! 	else
! 	{
! 	    Clear_Extended_File ();
! 	    return res;
! 	}
! 
! /* Failed - disabled */
! 
! 	Swap_Mode &= (~SWAP_EXTEND);
!     }
! 
! /* Try the disk if available */
! 
!     if (Swap_Mode & SWAP_DISK)
!     {
! 	SW_Pwrite = 0;
! 
! 	if (Swap_File == (char *)NULL)
! 	    SW_fp = S_open (FALSE, (ep = g_tempname ()), O_SMASK, 0600);
! 
! 	else
! 	{
! 	    SW_fp = S_open (FALSE, Swap_File, O_SaMASK);
! 	    SW_Pwrite = 1;
! 	}
! 
! 	if (SW_fp < 0)
! 	{
! 	    Clear_Swap_File ();
! 	    Swap_Mode &= (~SWAP_DISK);
! 	    print_error ("No Swap files\n");
! 	    errno = ENOSPC;
! 	    return -1;
! 	}
! 
! /* Save the swap file name ? */
! 
! 	if ((Swap_File == (char *)NULL) &&
! 	    ((Swap_File = strsave (ep, 0)) == null))
! 		Swap_File = (char *)NULL;
! 
! 	SW_Mode = 1;			/* Set Disk file swap		*/
! 
! /* Seek to correct location */
! 
! 	if (SW_Pwrite)
! 	{
!     	    long	loc = (long)(etext - _psp + 1) * 16L;
! 
! 	    if (lseek (SW_fp, loc, SEEK_SET) != loc)
! 	    {
! 		serrno = errno;
! 		S_close (SW_fp, TRUE);
! 		Clear_Swap_File ();
! 		Swap_Mode &= (~SWAP_DISK);
! 		print_error ("No Swap files\n");
! 		errno = serrno;
! 		return -1;
! 	    }
! 	}
! 
! /* Execute the program */
! 
! 	res = SA_spawn (envp);
! 
! /* Close the swap file and extended command line files */
! 
! 	Clear_Extended_File ();
! 	serrno = errno;
! 	S_close (SW_fp, TRUE);
! 	errno = serrno;
! 
! /* Check for out of swap space */
! 
! 	if (res == -2)
! 	{
! 	    Clear_Swap_File ();
! 	    Swap_Mode &= (~SWAP_DISK);
! 	    print_warn ("Swap file write failed\n");
! 	    errno = ENOSPC;
! 	    res = -1;
! 	}
! 
! /* Return the result */
! 
! 	return res;
!     }
! 
! /* No swapping available - give up */
! 
!     Clear_Extended_File ();
!     print_error ("All Swapping methods failed\n");
!     errno = ENOSPC;
!     return -1;
! }
! 
! /* Get the XMS Driver information */
! 
! static bool	Get_XMS_Driver ()
! {
!     union REGS		or;
!     struct SREGS	sr;
!     unsigned int	SW_EMsize;	/* Number of extend memory blks	*/
! 
! /* Get max Extended memory pages, and convert to 16K blocks.  If Extended
!  * memory swapping disabled, set to zero
!  */
! 
!     SW_fp = -1;				/* Set EMS/XMS handler not	*/
! 					/* defined			*/
! 
! /* Is a XMS memory driver installed */
! 
!     or.x.ax = 0x4300;
!     int86 (0x2f, &or, &or);
! 
!     if (or.h.al != 0x80)
!     {
! 	or.x.ax = 0x8800;
! 	int86 (0x15, &or, &or);
! 	SW_EMsize = or.x.ax / 16;
! 
! 	if ((SW_EMsize <= SW_Blocks) ||
! 	     ((SW_EMstart - 0x100000L +
! 	      ((long)(SW_Blocks - SW_EMsize) * 16L * 1024L)) < 0L))
! 	    return XMS_error ("Not enough Extended memory for swap\n", 0);
! 
! 	else
! 	    return TRUE;
!     }
! 
! /* Get the driver interface */
! 
!     or.x.ax = 0x4310;
!     int86x (0x2f, &or, &or, &sr);
!     SW_XMS_Driver = (void (*)())((unsigned long)(sr.es) << 16L | or.x.bx);
! 
!     if ((SW_XMS_Gversion () & 0xff00) != 0x0200)
! 	return XMS_error ("Warning: XMS Version != 2\n", 0);
! 
!     else if ((SW_fp = SW_XMS_Allocate (SW_Blocks * 16)) == -1)
! 	return XMS_error (XMS_emsg, errno);
! 
!     return TRUE;
! }
! 
! /* Get the EMS Driver information */
! 
! static bool	Get_EMS_Driver ()
! {
!     union REGS		or;
!     struct SREGS	sr;
!     char		*sp;
! 
! /* Set EMS/XMS handler not defined */
! 
!     SW_fp = -1;
! 
!     or.x.ax = 0x3567;
!     intdosx (&or, &or, &sr);
! 
!     sp = (char *)((unsigned long)(sr.es) << 16L | 10L);
! 
! /* If not there - disable */
! 
!     if (memcmp ("EMMXXXX0", sp, 8) != 0)
! 	return EMS_error ("Warning: EMS not available\n", 0);
  
!     or.h.ah = 0x40;			/* Check status			*/
!     int86 (0x67, &or, &or);
! 
!     if (or.h.ah != 0)
! 	return EMS_error (EMS_emsg, or.h.ah);
! 
! /* Check version greater than 3.2 */
! 
!     or.h.ah = 0x46;
!     int86 (0x67, &or, &or);
! 
!     if ((or.h.ah != 0) || (or.h.al < 0x32))
! 	return EMS_error ("Warning: EMS Version < 3.2\n", 0);
! 
! /*  get page frame address */
! 
!     or.h.ah = 0x41;
!     int86 (0x67, &or, &or);
! 
!     if (or.h.ah != 0)
! 	return EMS_error (EMS_emsg, or.h.ah);
! 
!     SW_EMSFrame = or.x.bx;		/* Save the page frame		*/
! 
! /* Get the number of pages required */
! 
!     or.h.ah = 0x43;
!     or.x.bx = SW_Blocks;
!     int86 (0x67, &or, &or);
! 
!     if (or.h.ah != 0)
! 	return EMS_error (EMS_emsg, or.h.ah);
! 
! /* Save the EMS Handler */
! 
!     SW_fp = or.x.dx;
! 
! /* save EMS page map */
! 
!     or.h.ah = 0x47;
!     or.x.dx = SW_fp;
!     int86 (0x67, &or, &or);
! 
!     return (or.h.ah != 0) ? EMS_error (EMS_emsg, or.h.ah) : TRUE;
! }
! 
! /* Print EMS error message */
! 
! static bool	EMS_error (s, v)
! char		*s;
! int		v;
! {
!     print_warn (s, v);
!     Swap_Mode &= ~(SWAP_EXPAND);
!     EMS_Close ();
!     return FALSE;
! }
! 
! /* Print XMS error message */
! 
! static bool	XMS_error (s, v)
! char		*s;
! int		v;
! {
!     print_warn (s, v);
!     Swap_Mode &= ~(SWAP_EXTEND);
!     XMS_Close ();
!     return FALSE;
! }
! 
! /* If the XMS handler is defined - close it */
! 
! static int	XMS_Close ()
! {
!     int		res = 0;
! 
! /* Release XMS page */
! 
!     if (SW_fp != -1)
! 	res = SW_XMS_Free (SW_fp);
! 
!     SW_fp = -1;
!     return res;
! }
! 
! /* If the EMS handler is defined - close it */
! 
! static int	EMS_Close ()
! {
!     union REGS		or;
!     int			res = 0;
! 
!     if (SW_fp == -1)
! 	return 0;
! 
! /* Restore EMS page */
! 
!     or.h.ah = 0x48;
!     or.x.dx = SW_fp;
!     int86 (0x67, &or, &or);
! 
!     if (or.h.ah != 0)
! 	res = or.h.al;
! 
!     or.h.ah = 0x45;
!     or.x.dx = SW_fp;
!     int86 (0x67, &or, &or);
! 
!     SW_fp = -1;
!     return (res) ? res : or.h.ah;
  }
  
  /* Set up command line.  If the EXTENDED_LINE variable is set, we create
--- 1299,1307 ----
      else if (access (path_line, F_OK) != 0)
  	return -1;
  
! /* Process the command line. */
  
!     return build_command_line (path_line, parms, envp);
  }
  
  /* Set up command line.  If the EXTENDED_LINE variable is set, we create
***************
*** 1653,1658 ****
--- 1324,1331 ----
      bool		found;
      char		*ep;
      char		*new_args[3];
+     char                cmd_line[CMD_LINE_MAX];
+     void 		(*save_signal)(int);
  
  /* Translate process name to MSDOS format */
  
***************
*** 1746,1752 ****
  
  /* Correctly terminate cmd_line in no swap mode */
  
- 	    if (Swap_Mode != SWAP_OFF)
  	    cmd_line[cmd_line[0] + 2] = '\r';
  
  /* If the name in the file is in upper case - use \ for separators */
--- 1419,1424 ----
***************
*** 1756,1771 ****
  
  /* OK we are ready to execute */
  
- 	    if (Swap_Mode == SWAP_OFF)
- 	    {
  	    new_args[0] = *argv;
  	    new_args[1] = &cmd_line[1];
  	    new_args[2] = (char *)NULL;
- 		return spawnve (P_WAIT, path, new_args, envp);
- 	    }
  
! 	    else
! 		return 0;
  	}
      }
  
--- 1428,1441 ----
  
  /* OK we are ready to execute */
  
  	    new_args[0] = *argv;
  	    new_args[1] = &cmd_line[1];
  	    new_args[2] = (char *)NULL;
  
!             save_signal = signal (SIGINT, SIG_DFL);
! 	    res = spawnve (spawnmode, path, new_args, envp);
!             signal (SIGINT, save_signal);
!             return res;
  	}
      }
  
***************
*** 1805,1813 ****
  
      cmd_line[0] = (char)res;
  
! /* If swapping disabled - just execute it */
  
!     return (Swap_Mode == SWAP_OFF) ? spawnve (P_WAIT, path, argv, envp) : 0;
  }
  
  /* Check string for white space */
--- 1475,1486 ----
  
      cmd_line[0] = (char)res;
  
! /* Just execute it */
  
!     save_signal = signal (SIGINT, SIG_DFL);
!     res = spawnve (spawnmode, path, argv, envp);
!     signal (SIGINT, save_signal);
!     return res;
  }
  
  /* Check string for white space */
***************
*** 1844,1862 ****
      Extend_file = (char *)NULL;
  }
  
- /* Clear Disk swap file file */
- 
- void	Clear_Swap_File ()
- {
-     if (Swap_File != (char *)NULL)
-     {
- 	unlink (Swap_File);
- 	DELETE (Swap_File);
-     }
- 
-     Swap_File = (char *)NULL;
- }
- 
  /* Convert the executable path to the full path name */
  
  static char	*Gen_Full_Path_Name (path)
--- 1517,1522 ----
***************
*** 1890,1898 ****
  
  /* Switch drives and get the path of the other drive */
  
! 	    _dos_setdrive (tolower (*path) - 'a' + 1, &dummy);
  	    getcwd (npath, PATH_MAX + 3);
! 	    _dos_setdrive (tolower (*cpath) - 'a' + 1, &dummy);
  	 }
      }
  
--- 1550,1558 ----
  
  /* Switch drives and get the path of the other drive */
  
! 	    DosSelectDisk(tolower (*path) - 'a' + 1);
  	    getcwd (npath, PATH_MAX + 3);
! 	    DosSelectDisk(tolower (*cpath) - 'a' + 1);
  	 }
      }
  
***************
*** 1921,1927 ****
  /* Change to the directory containing the executable */
  
  	if (*(path + 1) == ':')
! 	    _dos_setdrive (tolower (*path) - 'a' + 1, &dummy);
  
  /* Save the current directory on this drive */
  
--- 1581,1587 ----
  /* Change to the directory containing the executable */
  
  	if (*(path + 1) == ':')
! 	    DosSelectDisk(tolower (*path) - 'a' + 1);
  
  /* Save the current directory on this drive */
  
***************
*** 1942,1948 ****
  
  /* Restore our original directory */
  
! 	_dos_setdrive (tolower (*cpath) - 'a' + 1, &dummy);
  
  	if (chdir (cpath) < 0)
  	    return (char *)NULL;
--- 1602,1608 ----
  
  /* Restore our original directory */
  
! 	DosSelectDisk(tolower (*cpath) - 'a' + 1);
  
  	if (chdir (cpath) < 0)
  	    return (char *)NULL;
diff -cbBwr orig/SRC/sh4.c os2/SRC/sh4.c
*** orig/SRC/sh4.c	Wed Feb 20 21:25:06 1991
--- os2/SRC/sh4.c	Wed Feb 20 20:47:30 1991
***************
*** 59,73 ****
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
- #include <dirent.h>
  #include <string.h>
  #include <stdlib.h>
  #include <unistd.h>
  #include <ctype.h>
- #include <bios.h>
- #include <dos.h>
  #include "sh.h"
  
  /*
   * ${}, `command`, blank interpretation, quoting and file name expansion
   */
--- 59,76 ----
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
  #include <string.h>
  #include <stdlib.h>
+ #include <stdio.h>
  #include <unistd.h>
+ #include <dir.h>
  #include <ctype.h>
  #include "sh.h"
  
+ #define INCL_NOPM
+ #define INCL_DOS
+ #include <os2.h>
+ 
  /*
   * ${}, `command`, blank interpretation, quoting and file name expansion
   */
***************
*** 100,105 ****
--- 103,109 ----
  
  char		**eval(ap, f)
  register char	**ap;
+ int             f;
  {
      Word_B	*wb = (Word_B *)NULL;
      char	**wp = (char **)NULL;
***************
*** 269,274 ****
--- 273,279 ----
   */
  
  static char	*blank(f)
+ int             f;
  {
      register int	c, c1;
      register char	*sp = e.linep;
***************
*** 869,875 ****
  	if (any (*pp, spcl))
  	    i++;
  
! 	else if (!any (*pp & ~QUOTE, spcl))
  	    *pp &= ~QUOTE;
      }
  
--- 874,880 ----
  	if (any (*pp, spcl))
  	    i++;
  
! 	else if (!any ((char)(*pp & ~QUOTE), spcl))
  	    *pp &= ~QUOTE;
      }
  
***************
*** 945,951 ****
  {
      register char	*np, *cp;
      char		*name, *gp, *dp;
!     struct dirent	*d_ce;
      char		dname[NAME_MAX + 1];
      struct stat		dbuf;
  
--- 950,956 ----
  {
      register char	*np, *cp;
      char		*name, *gp, *dp;
!     struct direct	*d_ce;
      char		dname[NAME_MAX + 1];
      struct stat		dbuf;
  
***************
*** 990,996 ****
  
  /* Scan for matches */
  
!     while ((d_ce = readdir (e.cdir)) != (struct dirent *)NULL)
      {
   	if ((*(strncpy (dname, d_ce->d_name, NAME_MAX)) == '.') && (*gp != '.'))
    	    continue;
--- 995,1001 ----
  
  /* Scan for matches */
  
!     while ((d_ce = readdir (e.cdir)) != (struct direct *)NULL)
      {
   	if ((*(strncpy (dname, d_ce->d_name, NAME_MAX)) == '.') && (*gp != '.'))
    	    continue;
***************
*** 1030,1036 ****
      }
  
      closedir (e.cdir);
!     e.cdir = (DIR *)NULL;
      DELETE (dp);
      DELETE (gp);
  }
--- 1035,1041 ----
      }
  
      closedir (e.cdir);
!     e.cdir = NULL;
      DELETE (dp);
      DELETE (gp);
  }
***************
*** 1199,1248 ****
  char		*start;
  {
      unsigned int	c_drive;	/* Current drive		*/
-     unsigned int	m_drive;	/* Max drive			*/
-     unsigned int	s_drive;	/* Selected drive		*/
-     unsigned int	x_drive, y_drive;	/* Dummies		*/
      char		*multi;		/* Multi-drive flag		*/
      static char		*t_drive = "x";
      char		*new_pattern;
  
  /* Search all drives ? */
  
      if ((multi = Check_Multi_Drive (pattern)) != (char *)NULL)
      {
! 	_dos_getdrive (&c_drive);	/* Get number of drives		*/
! 	_dos_setdrive (c_drive, &m_drive);
! 	new_pattern = space (strlen (multi) + 2);
  
  	strcpy (new_pattern + 1, multi);
- 	*multi = 0;
  
! 	for (s_drive = 1; s_drive <= m_drive; ++s_drive)
  	  {
! 	    _dos_setdrive (s_drive, &x_drive);
! 	    _dos_getdrive (&y_drive);
! 	    _dos_setdrive (c_drive, &x_drive);
! 
! /* Check to see if the second diskette drive is really there */
! 
! 	    if (((_bios_equiplist () & 0x00c0) == 0x0000) && (s_drive == 2))
! 		continue;
! 
! /* If the drive exists and is in our list - process it */
! 
! 	    *t_drive = (char)(s_drive + 'a' - 1);
  
! 	    if ((y_drive == s_drive) &&
! 		 gmatch (t_drive, pattern, TRUE, (char **)NULL, GM_ALL))
  	      {
  	  	*new_pattern = *t_drive;
! 		globname (new_pattern, &new_pattern[2]);
  	      }
  	  }
  
  /* Restore and delete space */
  
- 	*multi = ':';
  	DELETE (new_pattern);
      }
  
--- 1204,1242 ----
  char		*start;
  {
      unsigned int	c_drive;	/* Current drive		*/
      char		*multi;		/* Multi-drive flag		*/
      static char		*t_drive = "x";
      char		*new_pattern;
+     ULONG               l_map;
+     int                 cnt;
  
  /* Search all drives ? */
  
      if ((multi = Check_Multi_Drive (pattern)) != (char *)NULL)
      {
!         DosQCurDisk((PUSHORT) &c_drive, &l_map);
  
+ 	new_pattern = space (strlen (multi) + 2);
  	strcpy (new_pattern + 1, multi);
  
!         for ( cnt = 1; cnt <= 26; cnt++, l_map >>= 1 )
!           if ( l_map & 1L )
  	  {
! 	      *t_drive = (char)(cnt + 'a' - 1);
!               *multi = 0;
  
! 	      if (gmatch (t_drive, pattern, TRUE, (char **)NULL, GM_ALL))
  	      {
  	  	*new_pattern = *t_drive;
!                 *multi = ':';
! 	  	globname (new_pattern, strchr(new_pattern,0));
  	      }
+               else
+                 *multi = ':';
  	  }
  
  /* Restore and delete space */
  
  	DELETE (new_pattern);
      }
  
diff -cbBwr orig/SRC/sh5.c os2/SRC/sh5.c
*** orig/SRC/sh5.c	Wed Feb 20 21:21:06 1991
--- os2/SRC/sh5.c	Fri Sep 07 18:46:04 1990
***************
*** 61,67 ****
  #include <fcntl.h>
  #include <io.h>
  #include <limits.h>
! #include <dirent.h>
  #include <unistd.h>
  #include "sh.h"
  
--- 61,67 ----
  #include <fcntl.h>
  #include <io.h>
  #include <limits.h>
! #include <dir.h>
  #include <unistd.h>
  #include "sh.h"
  
***************
*** 875,881 ****
   * Otherwise, write x
   */
  
! 		if ((c & QUOTE) && !any ((c & ~QUOTE), "$`\\"))
  		    Add_buffer ('\\', bp);
  
  		Add_buffer ((char)(c & (~QUOTE)), bp);
--- 875,881 ----
   * Otherwise, write x
   */
  
! 		if ((c & QUOTE) && !any ((char)(c & ~QUOTE), "$`\\"))
  		    Add_buffer ('\\', bp);
  
  		Add_buffer ((char)(c & (~QUOTE)), bp);
diff -cbBwr orig/SRC/sh6.c os2/SRC/sh6.c
*** orig/SRC/sh6.c	Wed Feb 20 21:25:16 1991
--- os2/SRC/sh6.c	Wed Feb 20 20:48:00 1991
***************
*** 71,83 ****
  #include <setjmp.h>
  #include <stdlib.h>
  #include <limits.h>
! #include <dirent.h>
  #include <unistd.h>
  #include <string.h>
  #include "sh.h"
  
! static char	*Copy_Right1 = "MS-DOS SH Version 1.6.4 - %s (DOS %d.%d)\n";
  static char	*Copy_Right2 = "Copyright (c) Data Logic Ltd and Charles Forsyth 1990\n";
  char		**dolv;		/* Parameter array			*/
  int		dolc;		/* Number of entries in parameter array	*/
  int		exstat;		/* Exit status				*/
--- 71,86 ----
  #include <setjmp.h>
  #include <stdlib.h>
  #include <limits.h>
! #include <proto.h>
! #include <dir.h>
  #include <unistd.h>
  #include <string.h>
  #include "sh.h"
  
! static char	*Copy_Right1 = "\nSH Version 1.6.4 - %s (OS/2 %d.%02d)\n";
  static char	*Copy_Right2 = "Copyright (c) Data Logic Ltd and Charles Forsyth 1990\n";
+ static char	*Copy_Right3 = "Ported to OS/2 by Kai Uwe Rommel 1990\n\n";
+ 
  char		**dolv;		/* Parameter array			*/
  int		dolc;		/* Number of entries in parameter array	*/
  int		exstat;		/* Exit status				*/
***************
*** 90,96 ****
  int		*failpt;	/* Current fail point jump address	*/
  int		*errpt;		/* Current error point jump address	*/
  				/* Swap mode				*/
- int		Swap_Mode = SWAP_EXPAND | SWAP_DISK;
  Break_C		*Break_List;	/* Break list for FOR/WHILE		*/
  Break_C		*Return_List;	/* Return list for RETURN		*/
  Break_C		*SShell_List;	/* SubShell list for EXIT		*/
--- 93,98 ----
***************
*** 169,175 ****
  {
      char	buf[100];
  
!     sprintf (buf, Copy_Right1, __DATE__, _osmajor, _osminor);
      write (fp, buf, strlen (buf));
      write (fp, Copy_Right2, strlen (Copy_Right2));
  }
--- 171,178 ----
  {
      char	buf[100];
  
!     sprintf (buf, Copy_Right1, __DATE__, _osmajor / 10, _osminor);
      write (fp, buf, strlen (buf));
      write (fp, Copy_Right2, strlen (Copy_Right2));
+     write (fp, Copy_Right3, strlen (Copy_Right3));
  }
diff -cbBwr orig/SRC/sh7.c os2/SRC/sh7.c
*** orig/SRC/sh7.c	Wed Feb 20 21:25:28 1991
--- os2/SRC/sh7.c	Wed Feb 20 21:30:10 1991
***************
*** 88,94 ****
  #include <sys/stat.h>
  #include <stdio.h>
  #include <process.h>
- #include <dos.h>
  #include <signal.h>
  #include <errno.h>
  #include <setjmp.h>
--- 88,93 ----
***************
*** 98,107 ****
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dirent.h>
  #include <stdarg.h>
  #include "sh.h"
  
  #define	SECS		60L
  #define	MINS		3600L
  #define IS_OCTAL(a)	(((a) >= '0') && ((a) <= '7'))
--- 97,110 ----
  #include <stdlib.h>
  #include <fcntl.h>
  #include <limits.h>
! #include <dir.h>
  #include <stdarg.h>
  #include "sh.h"
  
+ #define INCL_NOPM
+ #define INCL_DOS
+ #include <os2.h>
+ 
  #define	SECS		60L
  #define	MINS		3600L
  #define IS_OCTAL(a)	(((a) >= '0') && ((a) <= '7'))
***************
*** 112,118 ****
  #define FILE_READABLE	1
  #define FILE_WRITABLE	2
  #define FILE_REGULAR	3
! #define FILE_DIRECTORY	4
  #define FILE_NONZERO	5
  #define FILE_TERMINAL	6
  #define STRING_ZERO	7
--- 115,121 ----
  #define FILE_READABLE	1
  #define FILE_WRITABLE	2
  #define FILE_REGULAR	3
! #define _FILE_DIRECTORY	4
  #define FILE_NONZERO	5
  #define FILE_TERMINAL	6
  #define STRING_ZERO	7
***************
*** 154,160 ****
      {"-w",	FILE_WRITABLE,		UNARY_OP},
      {"-x",	FILE_EXECUTABLE,	UNARY_OP},
      {"-f",	FILE_REGULAR,		UNARY_OP},
!     {"-d",	FILE_DIRECTORY,		UNARY_OP},
      {"-s",	FILE_NONZERO,		UNARY_OP},
      {"-t",	FILE_TERMINAL,		UNARY_OP},
      {"-z",	STRING_ZERO,		UNARY_OP},
--- 157,163 ----
      {"-w",	FILE_WRITABLE,		UNARY_OP},
      {"-x",	FILE_EXECUTABLE,	UNARY_OP},
      {"-f",	FILE_REGULAR,		UNARY_OP},
!     {"-d",	_FILE_DIRECTORY,	UNARY_OP},
      {"-s",	FILE_NONZERO,		UNARY_OP},
      {"-t",	FILE_TERMINAL,		UNARY_OP},
      {"-z",	STRING_ZERO,		UNARY_OP},
***************
*** 190,196 ****
  #ifdef S_IFIFO
      {"-p",	FILE_FIFO,		UNARY_OP},
  #endif
!     {(char *)NULL,	NULL,		NULL}
  };
  
  static int		expr (int);
--- 193,199 ----
  #ifdef S_IFIFO
      {"-p",	FILE_FIFO,		UNARY_OP},
  #endif
!     {(char *)NULL,	0,		0}
  };
  
  static int		expr (int);
***************
*** 208,214 ****
  static int		doecho (C_Op *);
  static int		dogetopt (C_Op *);
  static int		dopwd (C_Op *);
- static int		doswap (C_Op *);
  static int		dounset (C_Op *);
  static int		dotype (C_Op *);
  static int		dotest (C_Op *);
--- 211,216 ----
***************
*** 229,234 ****
--- 231,239 ----
  static int		doreadonly (C_Op *);
  static int		doset (C_Op *);
  static int		dohistory (C_Op *);
+ extern int              dojobs(C_Op *);
+ extern int              docls(C_Op *);
+ 
  static void		setsig (int, int (*)());
  static int		rdexp (char **, int, char *);
  
***************
*** 466,588 ****
  }
  
  /*
!  * Display the current version
   */
  
! static int	dover (t)
  C_Op		*t;
  {
-     Print_Version (1);
      return 0;
  }
  
- static char	*swap_device[] = {"disk", "extend", "expand"};
- 
  /*
!  * Modify swapping information: swap options
   */
  
! static int	doswap (t)
! register C_Op	*t;
! {
!     register int	n = 1;
!     char		*cp;
! 
! /* Display current values ? */
! 
!     if (t->words[1] == (char *)NULL)
!     {
! 	if (Swap_Mode == SWAP_OFF)
! 	    v1a_puts ("Swapping disabled");
! 
! 	else
! 	{
! 	    register int	j;
! 
! 	    v1_puts ("Swap devices: ");
! 
! 	    for (j = 0, n = 1; j < 3; ++j, n <<= 1)
! 	    {
! 		if (Swap_Mode & n)
! 		{
! 		    v1printf ("%s ", swap_device[j]);
! 
! 		    if (n == SWAP_EXTEND)
! 			v1printf ("(0x%.6lx) ", SW_EMstart);
! 		}
! 	    }
! 
! 	    v1_putc (NL);
! 	}
! 
! 	return 0;
!     }
! 
! /* Set up new values */
! 
!     Swap_Mode = SWAP_OFF;
!     Clear_Swap_File ();
! 
!     while ((cp = t->words[n++]) != (char *)NULL)
! {
! 	if (strcmp (cp, "off") == 0)
! 	    Swap_Mode = SWAP_OFF;
! 
! 	else if (strcmp (cp, "on") == 0)
! 	    Swap_Mode = SWAP_DISK | SWAP_EXPAND | SWAP_EXTEND;
! 
! /* Scan for valid arguments */
! 
! 	else
! 	{
! 	    register int	j, k;
! 
! 	    for (j = 0, k = 1; j < 3; ++j, k <<= 1)
! 	    {
! 		if (strcmp (cp, swap_device[j]) == 0)
! 		{
! 		    Swap_Mode |= k;
! 
! /* If extended memory, they can specify the start address as a hex number */
! 
! 		    if (k == SWAP_EXTEND)
  		    {
! 			char	*sp;
! 			long	start;
! 
! /* Check for not changed */
! 
! 			if ((sp = t->words[n]) == (char *)NULL)
! 			    break;
! 
! /* Convert hex number */
! 
! 			start = strtol (sp, &sp, 16);
! 
! /* If not completely a hex number, ignore */
! 
! 			if (*sp)
! 			    break;
! 
! /* Set used and saved new value */
! 
! 			SW_EMstart = start;
! 			++n;
! 
! 			if ((SW_EMstart < 0x100000L) ||
! 			    (SW_EMstart > 0xf00000L))
! 			    SW_EMstart = 0x100000L;
! 
! 			v1printf ("Extend memory start set to 0x%.6lx\n",
! 				  SW_EMstart);
! 		    }
! 
! 		    break;
! 		}
! 	    }
! 	}
!     }
! 
      return 0;
  }
  
--- 471,493 ----
  }
  
  /*
!  * Do nothing
   */
  
! static int	donothing (t)
  C_Op		*t;
  {
      return 0;
  }
  
  /*
!  * Display the current version
   */
  
! static int	dover (t)
! C_Op		*t;
  {
!     Print_Version (1);
      return 0;
  }
  
***************
*** 859,865 ****
  	case FILE_REGULAR:
  	    return stat (*test_alist, &s) == 0 && S_ISREG(s.st_mode);
  
! 	case FILE_DIRECTORY:
  	    return stat (*test_alist, &s) == 0 && S_ISDIR(s.st_mode);
  
  	case FILE_NONZERO:
--- 764,770 ----
  	case FILE_REGULAR:
  	    return stat (*test_alist, &s) == 0 && S_ISREG(s.st_mode);
  
! 	case _FILE_DIRECTORY:
  	    return stat (*test_alist, &s) == 0 && S_ISDIR(s.st_mode);
  
  	case FILE_NONZERO:
***************
*** 961,970 ****
  {
      unsigned int	cdrive;
      unsigned int	ndrive = tolower (**t->words) - 'a' + 1;
  
!     _dos_setdrive (ndrive, &cdrive);
      Getcwd ();
!     _dos_getdrive (&cdrive);
      return (ndrive == cdrive) ? 0 : 1;
  }
  
--- 866,876 ----
  {
      unsigned int	cdrive;
      unsigned int	ndrive = tolower (**t->words) - 'a' + 1;
+     ULONG l_map;
  
!     DosSelectDisk(ndrive);
      Getcwd ();
!     DosQCurDisk((PUSHORT) &cdrive, &l_map);
      return (ndrive == cdrive) ? 0 : 1;
  }
  
***************
*** 982,987 ****
--- 888,894 ----
      int			first = 0;
      unsigned int	dummy;
      unsigned int	cdrive;
+     ULONG l_map;
  
  /* If restricted shell - illegal */
  
***************
*** 1005,1011 ****
  
  /* Save the current drive */
  
!     _dos_getdrive (&cdrive);
  
  /* Scan for the directory.  If there is not a / or : at start, use the
   * CDPATH variable
--- 912,918 ----
  
  /* Save the current drive */
  
!     DosQCurDisk((PUSHORT) &cdrive, &l_map);
  
  /* Scan for the directory.  If there is not a / or : at start, use the
   * CDPATH variable
***************
*** 1024,1030 ****
  
  	if (*(nd + 1) == ':')
  	{
! 	    _dos_setdrive (tolower (*nd) - 'a' + 1, &dummy);
  	    nd += 2;
  	}
  
--- 931,937 ----
  
  	if (*(nd + 1) == ':')
  	{
! 	    DosSelectDisk(tolower (*nd) - 'a' + 1);
  	    nd += 2;
  	}
  
***************
*** 1051,1057 ****
  
  /* Restore our original drive and restore directory info */
  
!     _dos_setdrive (cdrive, &dummy);
      Getcwd ();
  
      print_error ("%s: bad directory\n", p);
--- 958,964 ----
  
  /* Restore our original drive and restore directory info */
  
!     DosSelectDisk(cdrive);
      Getcwd ();
  
      print_error ("%s: bad directory\n", p);
***************
*** 1773,1779 ****
   */
  
  static char	*type_ext[] = {
!     "", ".exe", ".com", ".sh", ".bat"
  };
  
  static int	dotype (t)
--- 1680,1686 ----
   */
  
  static char	*type_ext[] = {
!     "", ".exe", ".com", ".sh", BATCHEXT
  };
  
  static int	dotype (t)
***************
*** 1803,1809 ****
  
      while ((cp = t->words[n++]) != (char *)NULL)
      {
! 	if ( inbuilt (cp) )
          {
  	    v1_puts (cp);
  	    v1a_puts (" is a shell internal command");
--- 1710,1719 ----
  
      while ((cp = t->words[n++]) != (char *)NULL)
      {
! 
! /* Check for currently use inbuilt version */
! 
! 	if (inbuilt (cp, &inb) && inb)
  	{
  	    v1_puts (cp);
  	    v1a_puts (" is a shell internal command");
***************
*** 1861,1869 ****
  
  		    else if ((stricmp (xp, ".exe") != 0) &&
  			     (stricmp (xp, ".com") != 0) &&
! 			     (stricmp (xp, ".bat") != 0))
  			continue;
  
  		    Convert_Backslashes (strlwr (l_path));
  		    print_error ("%s is %s\n", cp, l_path);
  		    found = TRUE;
--- 1770,1779 ----
  
  		    else if ((stricmp (xp, ".exe") != 0) &&
  			     (stricmp (xp, ".com") != 0) &&
! 			     (stricmp (xp, BATCHEXT) != 0))
  			continue;
  
+                     strlwr(l_path);
  		    Convert_Backslashes (strlwr (l_path));
  		    print_error ("%s is %s\n", cp, l_path);
  		    found = TRUE;
***************
*** 1898,1903 ****
--- 1808,1814 ----
  	"break",	dobreak,	BLT_CURRENT,
  	"builtin",	dobuiltin,	(BLT_ALWAYS | BLT_CURRENT),
  	"cd",		dochdir,	BLT_CURRENT,
+ 	"cls",		docls,          BLT_CURRENT,
  	"continue",	docontinue,	BLT_CURRENT,
  	"echo",		doecho,		BLT_CURRENT,
  	"eval",		doeval,		BLT_CURRENT,
***************
*** 1904,1913 ****
--- 1815,1826 ----
  	"exec",		doexec,		BLT_CURRENT,
  	"exit",		doexit,		BLT_CURRENT,
  	"export",	doexport,	BLT_CURRENT,
+         "extproc",      donothing,      BLT_CURRENT,
  	"getopt",	dogetopt,	BLT_CURRENT,
  #ifndef NO_HISTORY
  	"history",	dohistory,	BLT_CURRENT,
  #endif
+         "jobs",         dojobs,         BLT_CURRENT,
  	"msdos",	domsdos,	BLT_CURRENT,
  	"pwd",		dopwd,		BLT_CURRENT,
  	"read",		doread,		BLT_CURRENT,
***************
*** 1915,1921 ****
  	"return",	doreturn,	BLT_CURRENT,
  	"set",		doset,		BLT_CURRENT,
  	"shift",	doshift,	BLT_CURRENT,
- 	"swap",		doswap,		BLT_CURRENT,
  	"test",		dotest,		BLT_CURRENT,
  	"trap",		dotrap,		BLT_CURRENT,
  	"type",		dotype,		BLT_CURRENT,
--- 1828,1833 ----
***************
*** 1962,1968 ****
   * Equivalent of printf without using streams
   */
  
! void	v1printf (fmt)
  char	*fmt;
  {
      va_list	ap;
--- 1874,1880 ----
   * Equivalent of printf without using streams
   */
  
! void	v1printf (fmt, ...)
  char	*fmt;
  {
      va_list	ap;
diff -cbBwr orig/SRC/sh8.c os2/SRC/sh8.c
*** orig/SRC/sh8.c	Wed Feb 20 21:25:10 1991
--- os2/SRC/sh8.c	Wed Feb 20 20:22:18 1991
***************
*** 61,66 ****
--- 61,67 ----
  #include <errno.h>
  #include <setjmp.h>
  #include <stdlib.h>
+ #include <stdio.h>
  #include <fcntl.h>
  #include <io.h>
  #include <stdarg.h>
***************
*** 67,73 ****
  #include <string.h>
  #include <unistd.h>
  #include <limits.h>
! #include <dirent.h>
  #include <ctype.h>
  #include "sh.h"
  
--- 68,74 ----
  #include <string.h>
  #include <unistd.h>
  #include <limits.h>
! #include <dir.h>
  #include <ctype.h>
  #include "sh.h"
  
***************
*** 97,103 ****
   * for a normal open.
   */
  
! int	S_open (d_flag, name, mode)
  bool	d_flag;
  char	*name;
  int	mode;
--- 98,104 ----
   * for a normal open.
   */
  
! int	S_open (d_flag, name, mode, ...)
  bool	d_flag;
  char	*name;
  int	mode;
***************
*** 598,604 ****
  /* Try the file name and then with a .sh appended */
  
      if ((i = Check_Script (strcpy (local_path, path), params, nargs)) < 0)
! 	i = Check_Script (strcat (local_path, ".sh"), params, nargs);
  
      DELETE (local_path);
      return i;
--- 599,606 ----
  /* Try the file name and then with a .sh appended */
  
      if ((i = Check_Script (strcpy (local_path, path), params, nargs)) < 0)
!       if ((i = Check_Script (strcat (local_path, ".sh"), params, nargs)) == 0)
!         strcpy(path, local_path);
  
      DELETE (local_path);
      return i;
diff -cbBwr orig/SRC/sh9.c os2/SRC/sh9.c
*** orig/SRC/sh9.c	Wed Feb 20 21:21:22 1991
--- os2/SRC/sh9.c	Mon Sep 10 12:19:18 1990
***************
*** 74,84 ****
  #include <errno.h>
  #include <setjmp.h>
  #include <limits.h>
- #include <dos.h>
  #include <unistd.h>
! #include <dirent.h>
  #include "sh.h"
  
  /* Keyboard functions */
  
  #define KF_LENGTH		(sizeof (KF_List) / sizeof (KF_List[0]))
--- 74,87 ----
  #include <errno.h>
  #include <setjmp.h>
  #include <limits.h>
  #include <unistd.h>
! #include <dir.h>
  #include "sh.h"
  
+ #define INCL_NOPM
+ #define INCL_VIO
+ #include <os2.h>
+ 
  /* Keyboard functions */
  
  #define KF_LENGTH		(sizeof (KF_List) / sizeof (KF_List[0]))
***************
*** 99,107 ****
  #define KF_DELETELEFT	0x0e		/* Delete left character	*/
  #define KF_COMPLETE	0x0f		/* Complete file name		*/
  #define KF_DIRECTORY	0x10		/* Complete directory function	*/
! #define KF_END_FKEYS	0x11		/* End of function keys		*/
! #define KF_RINGBELL	0x11		/* Ring bell			*/
! #define KF_HALFHEIGTH	0x12		/* Half height cursor		*/
  
  /* Function Declarations */
  
--- 102,113 ----
  #define KF_DELETELEFT	0x0e		/* Delete left character	*/
  #define KF_COMPLETE	0x0f		/* Complete file name		*/
  #define KF_DIRECTORY	0x10		/* Complete directory function	*/
! #define KF_JOBS         0x11            /* Jobs list */
! #define KF_CLS          0x12            /* Jobs list */
! #define KF_END_FKEYS	0x13		/* End of function keys		*/
! #define KF_RINGBELL	0x13		/* Ring bell			*/
! #define KF_HALFHEIGTH	0x14		/* Half height cursor		*/
! 
  
  /* Function Declarations */
  
***************
*** 130,136 ****
  static int	Max_Cols  = 80;		/* Max columns			*/
  static int	Max_Lines = 25;		/* Max Lines			*/
  #ifndef NO_HISTORY
! static bool	insert_mode = FALSE;
  static char	*c_buffer_pos;		/* Position in command line	*/
  static char	*end_buffer;		/* End of command line		*/
  static int	m_line = 0;		/* Max write line number	*/
--- 136,142 ----
  static int	Max_Cols  = 80;		/* Max columns			*/
  static int	Max_Lines = 25;		/* Max Lines			*/
  #ifndef NO_HISTORY
! static bool	insert_mode = TRUE;
  static char	*c_buffer_pos;		/* Position in command line	*/
  static char	*end_buffer;		/* End of command line		*/
  static int	m_line = 0;		/* Max write line number	*/
***************
*** 162,180 ****
      { "WordRight",	0,	't',	KF_WORDRIGHT },
      { "WordLeft",	0,	's',	KF_WORDLEFT },
      { "Start",		0,	'G',	KF_START },
!     { "Clear",		0,	'v',	KF_CLEAR },
      { "Flush",		0,	'u',	KF_FLUSH },
      { "End",		0,	'O',	KF_END },
      { "Insert",		0,	'R',	KF_INSERT },
      { "DeleteRight",	0,	'S',	KF_DELETERIGHT },
      { "DeleteLeft",	0x08,	0,	KF_DELETELEFT },
!     { "Complete",	0,	'w',	KF_COMPLETE },
      { "Directory",	0,	0x0f,	KF_DIRECTORY },
  
  /* End of function keys - flags */
  
      { "Bell",		1,	0,	KF_RINGBELL },
!     { "HalfHeight",	0,	0,	KF_HALFHEIGTH }
  };
  
  /* Arrary of history Items */
--- 168,188 ----
      { "WordRight",	0,	't',	KF_WORDRIGHT },
      { "WordLeft",	0,	's',	KF_WORDLEFT },
      { "Start",		0,	'G',	KF_START },
!     { "Clear",		0x1b,	0,	KF_CLEAR },
      { "Flush",		0,	'u',	KF_FLUSH },
      { "End",		0,	'O',	KF_END },
      { "Insert",		0,	'R',	KF_INSERT },
      { "DeleteRight",	0,	'S',	KF_DELETERIGHT },
      { "DeleteLeft",	0x08,	0,	KF_DELETELEFT },
!     { "Complete",	0x09,	0,	KF_COMPLETE },
      { "Directory",	0,	0x0f,	KF_DIRECTORY },
+     { "Jobs",		0,	0x94,	KF_JOBS },
+     { "ClearScreen",	0x0C,	0,	KF_CLS },
  
  /* End of function keys - flags */
  
      { "Bell",		1,	0,	KF_RINGBELL },
!     { "HalfHeight",	1,	0,	KF_HALFHEIGTH }
  };
  
  /* Arrary of history Items */
***************
*** 238,244 ****
  
      while (TRUE)
      {
! 	Init_Input (FALSE);			/* Initialise		*/
  
  	while (((a_key = (char)getch ()) != 0x1a) && (a_key != NL) &&
  		(a_key != '\r'))
--- 246,252 ----
  
      while (TRUE)
      {
! 	Init_Input (TRUE);			/* Initialise		*/
  
  	while (((a_key = (char)getch ()) != 0x1a) && (a_key != NL) &&
  		(a_key != '\r'))
***************
*** 246,251 ****
--- 254,262 ----
  
  /* If function key, get the fkey value */
  
+             if ( a_key == 0xE0 )
+               a_key = 0;
+ 
  	    if (!a_key)
  		f_key = (char)getch ();
  
***************
*** 482,487 ****
--- 493,511 ----
  
     	    return TRUE;
  
+         case KF_JOBS:
+ 	    v1_putc (NL);
+             dojobs(NULL);
+ 	    put_prompt (last_prompt);
+ 	    read_cursor_position ();
+             return TRUE;
+ 
+         case KF_CLS:
+             docls(NULL);
+ 	    put_prompt (last_prompt);
+ 	    read_cursor_position ();
+             return TRUE;
+ 
  	case KF_DIRECTORY:		/* File name directory		*/
  	    fn_search = TRUE;
  
***************
*** 521,540 ****
  static void	set_cursor_shape (mode)
  bool		mode;
  {
!     union REGS		r;
! 
! /* Get the current cursor position to get the cursor lines */
! 
!     r.h.ah = 0x03;
!     int86 (0x10, &r, &r);
  
! /* Reset the type */
  
!     r.h.ah = 0x01;
!     r.h.ch = (unsigned char)(!mode ? r.h.cl - 1
! 				   : (KF_List[KF_HALFHEIGTH].akey
! 					? (r.h.cl / 2) + 1 : 1));
!     int86 (0x10, &r, &r);
  }
  #endif
  
--- 545,558 ----
  static void	set_cursor_shape (mode)
  bool		mode;
  {
!   VIOCURSORINFO vioci;
  
!   vioci.yStart = mode ? (KF_List[KF_HALFHEIGTH].akey ? -50 : 0) : -90;
!   vioci.cEnd = -100;
!   vioci.cx = 0;
!   vioci.attr = 0;
  
!   VioSetCurType(&vioci, 0);
  }
  #endif
  
***************
*** 542,553 ****
  
  static void	read_cursor_position ()
  {
!     union REGS	r;
  
!     r.h.ah = 0x03;				/* Read cursor position	*/
!     r.h.bh = 0;					/* Page zero		*/
!     int86 (0x10, &r, &r);
!     s_cursor = (r.h.dh * Max_Cols) + r.h.dl;
  }
  
  /* Re-position the cursor */
--- 560,569 ----
  
  static void	read_cursor_position ()
  {
!     USHORT usRow, usColumn;
  
!     VioGetCurPos(&usRow, &usColumn, 0);
!     s_cursor = (usRow * Max_Cols) + usColumn;
  }
  
  /* Re-position the cursor */
***************
*** 557,579 ****
  int		new;
  {
      int diff;
!     union REGS	r;
  
!     r.h.ah = 0x02;				/* Set new position	*/
!     r.h.bh = 0;					/* Page zero		*/
!     r.h.dh = (unsigned char)(new / Max_Cols);
!     r.h.dl = (unsigned char)(new % Max_Cols);
  
  /* Are we at the bottom of the page? */
  
!     if (r.h.dh >= (unsigned char)Max_Lines)
      {
! 	diff = r.h.dh + 1 - Max_Lines;
! 	r.h.dh = (unsigned char)(Max_Lines - 1);
  	s_cursor -= Max_Cols * diff;
      }
  
!     int86 (0x10, &r, &r);
  }
  
  /* Erase to end of line (avoid need for STUPID ansi.sys memory eater!) */
--- 573,593 ----
  int		new;
  {
      int diff;
!     USHORT usRow, usColumn;
  
!     usRow    = (unsigned char)(new / Max_Cols);
!     usColumn = (unsigned char)(new % Max_Cols);
  
  /* Are we at the bottom of the page? */
  
!     if (usRow >= (unsigned char)Max_Lines)
      {
! 	diff = usRow + 1 - Max_Lines;
! 	usRow = (unsigned char)(Max_Lines - 1);
  	s_cursor -= Max_Cols * diff;
      }
  
!     VioSetCurPos(usRow, usColumn, 0);
  }
  
  /* Erase to end of line (avoid need for STUPID ansi.sys memory eater!) */
***************
*** 580,610 ****
  
  static void	erase_to_end_of_line ()
  {
!     union REGS		r;
!     unsigned char	backg;
  
! /* Get the background attribute of the cursor */
! 
!     r.h.ah = 0x08;
!     r.h.bh = 0;
!     int86 (0x10, &r, &r);
!     backg = r.h.ah & 0x07;
! 
!     r.h.ah = 0x03;
!     r.h.bh = 0;
!     int86 (0x10, &r, &r);
! 
! /* Check that we use the correct m_line */
! 
!     if (m_line < r.h.dh)
! 	m_line = r.h.dh;
! 
!     if ((r.x.cx = Max_Cols - r.h.dl + (m_line - r.h.dh) * Max_Cols) > 0)
!     {
! 	r.x.ax = 0x0a20;
! 	r.x.bx = backg;
! 	int86 (0x10, &r, &r);
! }
  }
  
  /* Generate the new cursor position */
--- 594,603 ----
  
  static void	erase_to_end_of_line ()
  {
!     USHORT usRow, usColumn;
  
!     VioGetCurPos(&usRow, &usColumn, 0);
!     VioWrtNChar(" ", Max_Cols - usColumn, usRow, usColumn, 0);
  }
  
  /* Generate the new cursor position */
***************
*** 1069,1075 ****
      int			fn_len, pre_len, i;
      DIR			*dn;
      char		d_name [NAME_MAX + 1];
!     struct dirent	*d_ce;
      int			found_cnt = 0;
      int			max_per_line;
      static char		*ms_drive = "a:/";
--- 1062,1068 ----
      int			fn_len, pre_len, i;
      DIR			*dn;
      char		d_name [NAME_MAX + 1];
!     struct direct	*d_ce;
      int			found_cnt = 0;
      int			max_per_line;
      static char		*ms_drive = "a:/";
***************
*** 1176,1182 ****
  
  /* Scan the directory */
  
!     while ((d_ce = readdir (dn)) != (struct dirent *)NULL)
      {
  	if (strnicmp (d_ce->d_name, fn_mstart, fn_len) == 0)
  	{
--- 1169,1175 ----
  
  /* Scan the directory */
  
!     while ((d_ce = readdir (dn)) != (struct direct *)NULL)
      {
  	if (strnicmp (d_ce->d_name, fn_mstart, fn_len) == 0)
  	{
***************
*** 1269,1274 ****
--- 1262,1268 ----
      c_buffer_pos = l_buffer;	/* Initialise			*/
      end_buffer = l_buffer;
      insert_mode = im;
+     set_cursor_shape (insert_mode);
      M_length = -1;
  
  /* Reset max line length and get the number of columns */
***************
*** 1411,1426 ****
  
  void	In_Col_Zero ()
  {
!     union REGS		r;
  
      Get_Screen_Params ();
      read_cursor_position ();
  
!     r.h.ah = 0x08;
!     r.h.bh = 0x00;
!     int86 (0x10, &r, &r);
  
!     if ((s_cursor % Max_Cols) || (r.h.al != ' '))
  	v1_putc (NL);
  }
  
--- 1405,1421 ----
  
  void	In_Col_Zero ()
  {
!     CHAR str[1];
!     USHORT cb = sizeof(str);
!     USHORT usRow, usColumn;
  
      Get_Screen_Params ();
      read_cursor_position ();
  
!     VioGetCurPos(&usRow, &usColumn, 0);
!     VioReadCharStr(str, &cb, usRow, usColumn, 0);
  
!     if ((s_cursor % Max_Cols) || (str[0] != ' '))
  	v1_putc (NL);
  }
  
***************
*** 1428,1453 ****
  
  static void	Get_Screen_Params ()
  {
!     union REGS		r;
! 
!     Max_Cols = *(int *)(0x0040004aL);
!     Max_Lines = 25;
! 
! /* Is this an EGA?  This test was found in NANSI.SYS */
  
!     r.h.ah = 0x12;
!     r.x.bx = 0xff10;
!     int86 (0x10, &r, &r);
  
!     if (r.x.bx & 0xfefc)
! 	return;
  
! /* Else read the number of rows */
  
!     r.x.ax = 0x1130;
!     r.h.bh = 0;
!     int86 (0x10, &r, &r);
!     Max_Lines = r.h.dl + 1;
  }
  
  /* Ring Bell ? */
--- 1423,1448 ----
  
  static void	Get_Screen_Params ()
  {
!     VIOMODEINFO viomi;
  
!     viomi.cb = sizeof(viomi);
!     VioGetMode(&viomi, 0);
  
!     Max_Cols  = viomi.col;
!     Max_Lines = viomi.row;
! }
  
! /* Clear Screen */
  
! int docls(C_Op *dummy)
! {
!     v1_putc (27);
!     v1_putc ('[');
!     v1_putc ('2');
!     v1_putc ('J');
!     v1_putc (27);
!     v1_putc ('[');
!     v1_putc ('H');
  }
  
  /* Ring Bell ? */
diff -cbBwr orig/SRC/unistd.h os2/SRC/unistd.h
*** orig/SRC/unistd.h	Wed Feb 20 21:21:24 1991
--- os2/SRC/unistd.h	Mon May 21 20:26:10 1990
***************
*** 4,10 ****
  /*  unistd.h  */
  
  #include <sys/types.h>
! #include <sys/proto.h>
  
  /* Definition for NULL pointer */
  
--- 4,11 ----
  /*  unistd.h  */
  
  #include <sys/types.h>
! #include <proto.h>
! #include <changes.h>
  
  /* Definition for NULL pointer */
  
