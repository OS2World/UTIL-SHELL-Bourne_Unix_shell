This is the OS/2 version of the MS-DOS SH 1.6.2

Changes:

- background processes with & character, reporting of exit status of
  ending bg processes and waiting for child processes on exit

- "jobs" command and jobs-key (default Ctrl-Tab) for list of actual
  background processes

- real OS/2 pipes, except on `` commands

- increased length of expanded command line (2k, max. would be 32k)
  instead of 127 bytes in DOS version

- #! in shell scripts works now correctly with, for example, gawk

- the "type" internal command of sh was changed to recognize
  the internal commands of sh as well as CMD.EXE commands

- a fatal bug with commands in () ("sub-shell") was fixed


Original DOS manual:

------8<-------------------------8<------------------------------
NAME
     sh, rsh - shell, the standard/restricted command programming
     language

SYNOPSIS
     sh [ -acefhiknmrstuvx ] [ args ]
     rsh [ -acefhiknmrstuvx ] [ args ]

DESCRIPTION
     Sh is a command programming language that executes commands
     read from a terminal or a file.  Rsh is a restricted version
     of the standard command interpreter sh; it is used to set up
     login names and execution environments whose capabilities
     are more controlled than those of the standard shell.  See
     Invocation below for the meaning of arguments to the shell.

     Definitions
     A blank is a tab or a space.  A name is a sequence of
     letters, digits, or underscores beginning with a letter or
     underscore.  A parameter is a name, a digit, or any of the
     characters *, @, #, ?, -, $, and !.

     Commands
     A simple-command is a sequence of non-blank words separated
     by blanks.  The first word specifies the name of the command
     to be executed.  Except as specified below, the remaining
     words are passed as arguments to the invoked command.  The
     command name is passed as argument 0 (see exec(2)).  The
     value of a simple-command is its exit status if it ter-
     minates normally, or (octal) 200+status if it terminates
     abnormally (see signal(2) for a list of status values).

     A pipeline is a sequence of one or more commands separated
     by | (or, for historical compatibility, by ^).  The standard
     output of each command but the last is connected by a
     pipe(2) to the standard input of the next command.  Each
     command is run as a separate process; the shell waits for
     the last command to terminate.  The exit status of a pipe-
     line is the exit status of the last command.

     A list is a sequence of one or more pipelines separated by
     ;, &&, or ||, and optionally terminated by ;.  Of these
     three symbols, ; has a lower precedence than that of && and
     ||.  The symbols && and || also have equal precedence.  A
     semicolon (;) causes sequential execution of the preceding
     pipeline.  The symbol && (||) causes the list following it
     to be executed only if the preceding pipeline returns a zero
     (non-zero) exit status.  An arbitrary number of new-lines
     may appear in a list, instead of semicolons, to delimit com-
     mands.

     A command is either a simple-command or one of the follow-
     ing.  Unless otherwise stated, the value returned by a com-
     mand is that of the last simple-command executed in the com-
     mand.

     for name [ in word ... ] do list done
          Each time a for command is executed, name is set to the
          next word taken from the in word list.  If in word ...
          is omitted, then the for command executes the do list
          once for each positional parameter that is set (see
          Parameter Substitution below).  Execution ends when
          there are no more words in the list.
     case word in [ pattern [ | pattern ] ... ) list ;; ] ... esac
          A case command executes the list associated with the
          first pattern that matches word.  The form of the pat-
          terns is the same as that used for file-name generation
          (see File Name Generation) except that a slash, a lead-
          ing dot, or a dot immediately following a slash need
          not be matched explicitly, and the match is case sensi-
          tive.
     if list then list [ elif list then list ] ... [ else list ] fi
          The list following if is executed and, if it returns a
          zero exit status, the list following the first then is
          executed.  Otherwise, the list following elif is exe-
          cuted and, if its value is zero, the list following the
          next then is executed.  Failing that, the else list is
          executed.  If no else list or then list is executed,
          then the if command returns a zero exit status.
     while list do list done
          A while command repeatedly executes the while list and,
          if the exit status of the last command in the list is
          zero, executes the do list; otherwise the loop ter-
          minates.  If no commands in the do list are executed,
          then the while command returns a zero exit status;
          until may be used in place of while to negate the loop
          termination test.
     (list)
          Execute list in a sub-shell.  The shell creates a new
          environment in which to execute the list, but does not
          fork a sub-shell as a Unix system would.  The original
          environment is restored on completion.
     {list;}
          list is simply executed.
     name () {list;}
          Define a function which is referenced by name.  The
          body of the function is the list of commands between {
          and }.  Execution of functions is described below (see
          Execution).

     The following words are only recognized as the first word of
     a command and when not quoted:

     if then else elif fi case esac for while until do done { }

     Comments
     A word beginning with # causes that word and all the follow-
     ing characters up to a new-line to be ignored.

     Command Substitution
     The standard output from a command enclosed in a pair of
     grave accents (``) may be used as part or all of a word;
     trailing new-lines are removed.

     Parameter Substitution
     The character $ is used to introduce substitutable parame-
     ters.  There are two types of parameters, positional and
     keyword.  If parameter is a digit, it is a positional param-
     eter.  Positional parameters may be assigned values by set.
     Keyword parameters (also known as variables) may be assigned
     values by writing:

          name = value [ name = value ] ...

     Pattern-matching is not performed on value.  There cannot be
     a function and a variable with the same name.

     ${parameter}
          The value, if any, of the parameter is substituted.
          The braces are required only when parameter is followed
          by a letter, digit, or underscore that is not to be
          interpreted as part of its name.  If parameter is * or
          @, all the positional parameters, starting with $1, are
          substituted (separated by spaces).  Parameter $0 is set
          from argument zero when the shell is invoked.
     ${parameter:-word}
          If parameter is set and is non-null, substitute its
          value; otherwise substitute word.
     ${parameter:=word}
          If parameter is not set or is null set it to word; the
          value of the parameter is substituted.  Positional
          parameters may not be assigned to in this way.
     ${parameter:?word}
          If parameter is set and is non-null, substitute its
          value; otherwise, print word and exit from the shell.
          If word is omitted, the message ``parameter null or not
          set'' is printed.
     ${parameter:+word}
          If parameter is set and is non-null, substitute word;
          otherwise substitute nothing.

     In the above, word is not evaluated unless it is to be used
     as the substituted string, so that, in the following exam-
     ple, pwd is executed only if d is not set or is null:

          echo ${d:-`pwd`}

     If the colon (:) is omitted from the above expressions, the
     shell only checks whether parameter is set or not (It is not
     clear what this means).

     The following parameters are automatically set by the shell:
          # The number of positional parameters in decimal.
          - Flags supplied to the shell on invocation or by the
            set command.
          ? The decimal value returned by the last synchronously
            executed command.
          $ The process number of this shell.
          ! The process number of the last background command
            invoked.
          ~ The shell reserves all variables beginning with a ~
            for its own internal use and these variables cannot
            be accessed by the user.

     The following parameters are used by the shell:
          CDPATH
            The search path for the cd command.  (Note that
            becuase a colon is used by MSDOS to indicate a drive,
            a semi-colon is used to separate the path names
            instead of a colon - this implies that the CDPATH
            variable must be set using single or double quotes to
            surround the value).
          EXTENDED_LINE
            This parameter defines a file containing a list of
            command which can accept an Extended Command Line
            using the indirect command file character @.  When a
            command which can process the Extended Command Line
            finds a parameter starting with a @ in the command
            list, treats the rest of the parameter as a file and
            reads the parameters from that file.  Examples of
            this functionality include the Standard Linker and
            Librarian.  The filename defined by EXTENDED_LINE
            contains a list of command (including the .exe or
            .com extension) separated by a newlines.   If the
            command is in upper case, the file name on the com-
            mand line is set up with backslashes as the directory
            separator.  Otherwise, slashes (Unix style) are used.
            This functionality allows the user to get round the
            127 byte command line length limit of MSDOS.
          HISTFILE
            The file where command history is saved across login
            sessions.  The default value is $HOME/history.sh.
          HOME
            The default argument (home directory) for the cd com-
            mand.
          IFS
            Internal field separators, normally space, tab, and
            new-line.
          MAIL
            If this parameter is set to the name of a mail file
            and the MAILPATH parameter is not set, the shell
            informs the user of the arrival of mail in the speci-
            fied file.
          MAILCHECK
            This parameter specifies how often (in seconds) the
            shell will check for the arrival of mail in the files
            specified by the MAILPATH or MAIL parameters.  If set
            to 0, the shell will check before each prompt.
          MAILPATH
            A colon (:) separated list of file names.  If this
            parameter is set, the shell informs the user of the
            arrival of mail in any of the specified files. Each
            file name can be followed by % and a message that
            will be printed when the modification time changes.
            The default message is "you have mail".
          PATH
            The search path for commands (see Execution below).
            The user may not change PATH if executing under rsh.
            (Note that because a colon is used by MSDOS to indi-
            cate a drive, a semi-colon is used to separate the
            path names instead of a colon - this implies that the
            PATH variable must be set using single or double
            quotes to surround the value).
          PS1
            Primary prompt string, by default ``$ ''.
          PS2
            Secondary prompt string, by default ``> ''.
          SHELL
            When the shell is invoked, it scans the environment
            (see Environment below) for this name.  If it is
            found and there is an 'r' in the file name part of
            its value, the shell becomes a restricted shell.
          TMP
            The location of temporary files created by the shell.
     The shell gives default values to PATH, PS1, PS2, SHELL,
     HOME and IFS.
     Blank Interpretation
     After parameter and command substitution, the results of
     substitution are scanned for internal field separator char-
     acters (those found in IFS) and split into distinct argu-
     ments where such characters are found.  Explicit null argu-
     ments ("" or '') are retained.  Implicit null arguments
     (those resulting from parameters that have no values) are
     removed.
     File Name Generation
     Following substitution, each command word is scanned for the
     characters *, ? and [.  If one of these characters appears
     the word is regarded as a pattern.  The word is replaced
     with alphabetically sorted file names that match the
     pattern.  If no file name is found that matches the pattern,
     the word is left unchanged.  The character . at the start of
     a file name or immediately following a /, as well as the
     character / itself, must be matched explicitly.  When match-
     ing patterns for file names, the shell ignores the case of
     the pattern and the file directory entries.  Generated file
     names are always in lower case.
          * Matches any string, including the null string.
          ? Matches any single character.
          [ ... ]
            Matches any one of the enclosed characters.  A pair
            of characters separated by - matches any character
            lexically between the pair, inclusive.  If the first
            character following the opening ``['' is a ``!'' any
            character not enclosed is matched.

     Quoting
     The following characters have a special meaning to the shell
     and cause termination of a word unless quoted:

          ;  &  (  )  |  ^  <  >  new-line  space  tab

     A character may be quoted (i.e., made to stand for itself)
     by preceding it with a \.  The pair \new-line is ignored.
     All characters enclosed between a pair of single quote marks
     (''), except a single quote, are quoted.  Inside double
     quote marks (""), parameter and command substitution occurs
     and \ quotes the characters \, `, ", and $. "$*" is
     equivalent to "$1 $2 ...", whereas "$@" is equivalent to
     "$1" "$2" ....

     Prompting
     When used interactively, the shell prompts with the value of
     PS1 before reading a command.  If at any time a new-line is
     typed and further input is needed to complete a command, the
     secondary prompt (i.e., the value of PS2) is issued.

     Many people like to have the shell provide them with useful
     information in their prompt.  To accommodate this, the shell
     recognises special sequences of characters in the values of
     PS1 and PS2, and substitutes the appropriate information for
     them.  The special sequences and what they signify are:

          %dPlace the current date, in the form DAY DD-MM-YY into
            the prompt.

          %ePlace the current event number (as defined by the
            history command) into the prompt.  If history evalua-
            tion has been turned off (via history -d), no number
            will be substituted in (i.e. the %e will be removed).

          %nPlace the current working drive into the prompt.

          %pPlace the current working directory into the prompt.

          %tPlace the current time of day, in the form HH:MM into
            the prompt.  The time is on a 24 hour clock, i.e.
            1:30 in the afternoon will be 13:30.

          %vPlace the MSDOS version number, in the form  MSDOS
            MM:MM into the prompt.

          %%Place the character % into the prompt.

          \xxx
            Place the character \xxx into the prompt.  The pro-
            cessing of escape sequences is the same as that for
            echo.

     Some of these facilities are of more use than others.

     Input/Output
     Before a command is executed, its input and output may be
     redirected using a special notation interpreted by the
     shell.  The following may appear anywhere in a simple-
     command or may precede or follow a command and are not
     passed on to the invoked command; substitution occurs before
     word or digit is used:

     <word         Use file word as standard input (file descrip-
                   tor 0).
     >word         Use file word as standard output (file
                   descriptor 1).  If the file does not exist it
                   is created; otherwise, it is truncated to zero
                   length.
     >>word        Use file word as standard output.  If the file
                   exists output is appended to it (by first
                   seeking to the end-of-file); otherwise, the
                   file is created.
     <<[-]word     The shell input is read up to a line that is
                   the same as word, or to an end-of-file.  The
                   resulting document becomes the standard input.
                   If any character of word is quoted, no
                   interpretation is placed upon the characters
                   of the document; otherwise, parameter and com-
                   mand substitution occurs, (unescaped) \new-
                   line is ignored, and \ must be used to quote
                   the characters \, $, `, and the first charac-
                   ter of word.  If - is appended to <<, all
                   leading tabs are stripped from word and from
                   the document.
     <&digit       Use the file associated with file descriptor
                   digit as standard input.  Similarly for the
                   standard output using >&digit.
     <&-           The standard input is closed.  Similarly for
                   the standard output using >&-.

     If any of the above is preceded by a digit, the file
     descriptor which will be associated with the file is that
     specified by the digit (instead of the default 0 or 1).  For
     example:

          ... 2>&1

     associates file descriptor 2 with the file currently associ-
     ated with file descriptor 1.

     The order in which redirections are specified is signifi-
     cant.  The shell evaluates redirections left-to-right.  For
     example:

          ... 1>xxx 2>&1

     first associates file descriptor 1 with file xxx.  It asso-
     ciates file descriptor 2 with the file associated with file
     descriptor 1 (i.e. xxx).  If the order of redirections were
     reversed, file descriptor 2 would be associated with the
     terminal (assuming file descriptor 1 had been) and file
     descriptor 1 would be associated with file xxx .

     The environment for the execution of a command contains the
     file descriptors of the invoking shell as modified by
     input/output specifications.

     Redirection of output is not allowed in the restricted
     shell.

     Environment
     The environment (see environ(5)) is a list of name-value
     pairs that is passed to an executed program in the same way
     as a normal argument list.  The shell interacts with the
     environment in several ways.  On invocation, the shell scans
     the environment and creates a parameter for each name found,
     giving it the corresponding value.  If the user modifies the
     value of any of these parameters or creates new parameters,
     none of these affects the environment unless the export com-
     mand is used to bind the shell's parameter to the environ-
     ment (see also set -a).  A parameter may be removed from the
     environment with the unset command.  The environment seen by
     any executed command is thus composed of any unmodified
     name-value pairs originally inherited by the shell, minus
     any pairs removed by unset, plus any modifications or addi-
     tions, all of which must be noted in export commands.

     The environment for any simple-command may be augmented by
     prefixing it with one or more assignments to parameters.
     Thus:

          TERM=450 cmd args             and
          (export TERM; TERM=450; cmd args)

     are equivalent (as far as the execution of cmd is con-
     cerned).

     If the -k flag is set, all keyword arguments are placed in
     the environment, even if they occur after the command name.
     The following first prints a=b c and c:

          echo a=b c
          set -k
          echo a=b c

     Signals
     The INTERRUPT and QUIT signals for an invoked command are
     ignored if the command is followed by &; otherwise signals
     have the values inherited by the shell from its parent, with
     the exception of signal 11 (but see also the trap command
     below).

     History
     When reading input from an interactive terminal, a ``!'' at
     the start of a line signals to the shell that it should
     attempt to perform a history subsitution.  A history subsi-
     tution is a short-hand method which allows the user to
     recall a previous command for execution or editing.  The
     recalled command is placed in the command line for editing
     or passing to the rest of the shell for normal processing.
     A history substitution takes the form:

          ! [ str | num ] terminator

     !num will place the history command with the specified
     number in the command line.  !str will find the most recent
     command line that started with the characters in str.

     The terminator determines what action is performed after the
     history line has been found.  If the original history com-
     mand is entered using the <return> key, the new command line
     is passed directly to the shell.  If the <end> key is
     pressed, the new command line can be edited in the manner
     described below.

     Command Line Editing
     When reading input from an interactive terminal, certain
     keystrokes allow the current input line to be edited.  The
     following keystrokes are available:

     Cursor Right
          Move the cursor right one character

     Control-Cursor Right
          Move the cursor right one word

     Cursor Left
          Move the cursor left one character

     Control-Cursor Left
          Move the cursor left one word

     Cursor Up
          Get the previous command from the history file

     Cursor Down
          Get the next command from the history file

     Insert
          Toggle insert/overwrite mode

     Delete
          Delete the current character

     Home Move the cursor to the start of the command

     End  Move the cursor to the end of the command, unless the
          first character of the command is a !, in which case
          the appropriate history search is done.

     Control-End
          Delete to the end of the line

     Page-Up
          Search backwards from the current history command for
          the next match against the last history request.  This
          command can only be used after End has been used to
          select a history line.

     Page-Down
          Search forewards from the current history command for
          the next match against the last history request.  This
          command can only be used after End has been used to
          select a history line.

     Backspace
          Move the cursor back one character, erasing the current
          character.

     Return
          Execute the command line, unless the first character of
          the command is a !, in which case the appropriate his-
          tory processing is done.

     Execution
     Each time a command is executed, the above substitutions are
     carried out.  If the command name matches one of the Special
     Commands listed below, it is executed in the shell process.
     If the command name does not match a Special Command, but
     matches the name of a defined function, the function is exe-
     cuted in the shell process (note how this differs from the
     execution of shell procedures).  The positional parameters
     $1, $2, ....  are set to the arguments of the function.  If
     the command name matches neither a Special Command nor the
     name of a defined function, a new process is created and an
     attempt is made to execute the command via exec(2).

     The shell parameter PATH defines the search path for the
     directory containing the command.  Alternative directory
     names are separated by a semi-colon (;).  The default path
     is ;c:/bin;c:/usr/bin (specifying the current directory,
     c:/bin, and c:/usr/bin, in that order).  Note that the
     current directory is specified by a null path name, which
     can appear immediately after the equal sign or between the
     semi-colon delimiters anywhere else in the path list.  If
     the command name contains a / or starts with x: (where x is
     a drive letter) the search path is not used; such commands
     will not be executed by the restricted shell.  Otherwise,
     each directory in the path is searched for an executable
     file.

     If the file does not have a .com or .exe extension, it is
     opened and the first 5 characters are read.  If the first 5
     characters are the string #!sh\n it is assumed to be a file
     containing shell commands.  Note that the shell will check
     the file and if that file does not exist or is not a script,
     it will try the file with an extension of .sh.  If a .sh
     file is found, that will be processed.  A sub-shell is
     spawned to read it.  A parenthesized command is also exe-
     cuted in a sub-shell.

     Special Commands
     Input/output redirection is permitted for these commands.
     File descriptor 1 is the default output location.

     :    No effect; the command does nothing.  A zero exit code
          is returned.

     letter:
          Select the drive specified by letter.

     . file
          Read and execute commands from file and return.  The
          search path specified by PATH is used to find the
          directory containing file.

     break [ n ]
          Exit from the enclosing for or while loop, if any.  If
          n is specified, break n levels.

     continue [ n ]
          Resume the next iteration of the enclosing for or while
          loop.  If n is specified, resume at the n-th enclosing
          loop.

     cd [ arg ]
          Change the current directory to arg.  The shell parame-
          ter HOME is the default arg.  The shell parameter
          CDPATH defines the search path for the directory con-
          taining arg.  Alternative directory names are separated
          by a semi-colon (;).  The default path is <null>
          (specifying the current directory).  Note that the
          current directory is specified by a null path name,
          which can appear immediately after the equal sign or
          between the semi-colon delimiters anywhere else in the
          path list.  If arg begins with a / or x: (where x is a
          drive letter), the search path is not used.  Otherwise,
          each directory in the path is searched for arg.  The cd
          command may not be executed by rsh.

     echo [ arg ... ]
          Echo arguments. Echo writes its arguments separated by
          blanks and terminated by a new-line on the standard
          output.  It also understands C-like escape conventions;
          beware of conflicts with the shell's use of \:
          \bbackspace
          \cprint line without new-line
          \fform-feed
          \nnew-line
          \rcarriage return
          \ttab
          \vvertical tab
          \\backslash
          \nthe 8-bit character whose ASCII code is the 1-, 2- or
            3-digit octal number n, which must start with a zero.

          Echo is useful for producing diagnostics in command
          files and for sending known data into a pipe.

     eval [ arg ... ]
          The arguments are read as input to the shell and the
          resulting command(s) executed.

     exec [ arg ... ]
          The command specified by the arguments is executed in
          place of this shell without creating a new process.
          Input/output arguments may appear and, if no other
          arguments are given, cause the shell input/output to be
          modified.

     exit [ n ]
          Causes a shell to exit with the exit status specified
          by n.  If n is omitted the exit status is that of the
          last command executed (an end-of-file will also cause
          the shell to exit.)

     export [ name ... ]
          The given names are marked for automatic export to the
          environment of subsequently-executed commands.  If no
          arguments are given, a list of all names that are
          exported in this shell is printed.  Function names may
          not be exported.

     getopt optstring name [ args ... ]
          Parse command options and write them to standard out-
          put.  Getopt is used to break up options in command
          lines for easy parsing by shell procedures and to check
          for legal options.  Optstring is a string of recognized
          option letters (see getopt(3C)); if a letter is fol-
          lowed by a colon, the option is expected to have an
          argument which may or may not be separated from it by
          white space.  The special option -- is used to delimit
          the end of the options.  If it is used explicitly,
          getopt will recognize it; otherwise, getopt will gen-
          erate it; in either case, getopt will place it at the
          end of the options.  Each option is preceded by a - and
          is in its own positional parameter; each option argu-
          ment is also parsed into its own positional parameter.

          The following code fragment shows how one might process
          the arguments for a command that can take the options a
          or b, as well as the option o, which requires an argu-
          ment:

          set -- `getopt abo: $*`
          if [ $? != 0 ]
          then
               echo $USAGE
               exit 2
          fi
          for i in $*
          do
               case $i in
               -a | -b)  FLAG=$i; shift;;
               -o)       OARG=$2; shift 2;;
               --)       shift; break;;
               esac
          done

          This code will accept any of the following as
          equivalent:

          cmd -aoarg file file
          cmd -a -o arg file file
          cmd -oarg -a file file
          cmd -a -oarg -- file file

     history [ -dei ]
          The history command, with no arguments, will print all
          the commands that are currently saved in the shell's
          history buffers.  As new commands are executed, and
          space in the buffers runs out, old commands will be
          deleted.  The history commands prints out the stored
          commands with sequence numbers.  Negative numbered com-
          mands, through command number zero, are commands that
          were retrieved from the saved history file.  Commands
          starting at one were entered during the current login
          session.  If a saved command contains embedded new-
          lines, these will be printed out as the sequence \n, so
          that individual command stay on one line.

          The arguments changes the way the shell processes his-
          tory information as follows:

          -dDisable the saving of commands in the history file.

          -eEnable the saving of commands in the history file.

          -iInitialise the history file.

     msdos [ name ... ]
          The given names are marked msdos format and if the -m
          flag is set, the values of the these names are exported
          to child processes with the any slashes in the value
          replaced by backslashes.

     pwd  Print the current working directory.

     read [ name ... ]
          One line is read from the standard input and the first
          word is assigned to the first name, the second word to
          the second name, etc., with leftover words assigned to
          the last name.  The return code is 0 unless an end-of-
          file is encountered.

     readonly [ name ... ]
          The given names are marked readonly and the values of
          the these names may not be changed by subsequent
          assignment.  If no arguments are given, a list of all
          readonly names is printed.

     return [ n ]
          Causes a function to exit with the return value speci-
          fied by n.  If n is omitted, the return status is that
          of the last command executed.

     set [ --aefkmntuvx [ arg ... ] ]

          -aMark variables which are modified or created for
            export.

          -eExit immediately if a command exits with a non-zero
            exit status.

          -fDisable file name generation

          -kAll keyword arguments are placed in the environment
            for a command, not just those that precede the com-
            mand name.

          -mFor those variables marked as msdos variables, the
            values are exported to child processes with the
            slashes replaced by backslashes.  Most MSDOS utili-
            ties do not care if a file name contains a slash or
            backslash as a directory separator.  However, some
            like the linker require backslashes in the value of
            the LIB variable.

          -nRead commands but do not execute them.

          -tExit after reading and executing one command.

          -uTreat unset variables as an error when substituting.

          -vPrint shell input lines as they are read.

          -xPrint commands and their arguments as they are exe-
            cuted.

          --Do not change any of the flags; useful in setting $1
            to -.

          Using + rather than - causes these flags to be turned
          off.  These flags can also be used upon invocation of
          the shell.  The current set of flags may be found in
          $-.  The remaining arguments are positional parameters
          and are assigned, in order, to $1, $2, ....  If no
          arguments are given the values of all names are
          printed.

     shift [ n ]
          The positional parameters from $n+1 ...  are renamed $1
          ....  If n is not given, it is assumed to be 1.

     swap [ options ]
          This command defines how the shell will handle swap-
          ping.  The options are

          off
            Disable swapping.  The shell remains in memory whilst
            the child is running and reduces the available memory
            by about 200K (depending on the size of the environ-
            ment and history).

          onEnable all devices.  The shell will swap out to
            either expanded or extended memory or to disk, exe-
            cute the command and then swap back in.  Whilest
            swapped, the shell reduces the available memory by
            about 3K.

          expand
            Enable swapping to Expanded Memory.  The EMS drive
            must exist on your system for this to work.

          extent [ start address ]
            Enable swapping to Extended Memory.  The optional
            start address defines the based address in the
            Extended Memory at which point the shell writes its
            swap area.  The default location is 0x100000.

          disk
            Enable swapping to disk.  The shell creates a tem-
            porary file and saves itself in it.  On completion,
            the file is deleted.  This is the slowest method of
            swapping.

          With no options, the current swapping options are
          displayed.

     test expr or [ expr ]
          Evaluate conditional expressions.  Test evaluates the
          expression expr and, if its value is true, returns a
          zero (true) exit status; otherwise, a non-zero (false)
          exit status is returned; test also returns a non-zero
          exit status if there are no arguments.  The following
          primitives are used to construct expr:

          -r file     true if file exists and is readable.

          -w file     true if file exists and is writable.

          -x file     true if file exists and is executable.

          -f file     true if file exists and is a regular file.

          -d file     true if file exists and is a directory.

          -c file     true if file exists and is a character spe-
                      cial file.

          -b file     true if file exists and is a block special
                      file.

          -s file     true if file exists and has a size greater
                      than zero.

          -t [ fildes ]
                      true if the open file whose file descriptor
                      number is fildes (1 by default) is associ-
                      ated with a terminal device.

          -n s1       true if the length of the string s1 is
                      zero.

          -n s1       true if the length of the string s1 is
                      non-zero.

          s1 = s2     true if strings s1 and s2 are identical.

          s1 != s2    true if strings s1 and s2 are not identi-
                      cal.

          s1          true if s1 is not the null string.

          n1 -eq n2   true if the integers n1 and n2 are algebra-
                      ically equal.  Any of the comparisons -ne,
                      -gt, -ge, -lt, and -le may be used in place
                      of R-eq.

          These primaries may be combined with the following
          operators:

          !           unary negation operator.

          -a          binary and operator.

          -o          binary or operator (-a has higher pre-
                      cedence than -o).

          ( expr )    parentheses for grouping.

          Notice that all the operators and flags are separate
          arguments to test.  Notice also that parentheses are
          meaningful to the shell and, therefore, must be
          escaped.

     trap [ arg ] [ n ] ...
          The command arg is to be read and executed when the
          shell receives signal(s) n.  (Note that arg is scanned
          once when the trap is set and once when the trap is
          taken.) Trap commands are executed in order of signal
          number.  Any attempt to set a trap on a signal that was
          ignored on entry to the current shell is ineffective.
          An attempt to trap on signal 11 (memory fault) produces
          an error.  If arg is absent all trap(s) n are reset to
          their original values.  If arg is the null string this
          signal is ignored by the shell and by the commands it
          invokes.  If n is 0 the command arg is executed on exit
          from the shell.  The trap command with no arguments
          prints a list of commands associated with each signal
          number.

     type [ name ... ]
          For each name, indicate how it would be interpreted if
          used as a command name.

     umask [ nnn ]
          The user file-creation mask is set to nnn (see
          umask(2)).  If nnn is omitted, the current value of the
          mask is printed.

     unset [ name ... ]
          For each name, remove the corresponding variable or
          function.  The variables PATH, PS1, PS2, and IFS cannot
          be unset.

     ver  Display the current version of the shell.

     Invocation
     If the shell is invoked through exec(2) and the first char-
     acter of argument zero is - or the -0(zero) switch is in the
     invokation line, commands are initially read from
     /etc/profile.sh and from $HOME/profile.sh, if such files
     exist.  Thereafter, commands are read as described below,
     which is also the case when the shell is invoked as /bin/sh.
     The flags below are interpreted by the shell on invocation
     only; Note that unless the -c or -s flag is specified, the
     first argument is assumed to be the name of a file contain-
     ing commands, and the remaining arguments are passed as
     positional parameters to that command file:

     -c string If the -c flag is present commands are read from
               string.
     -s        If the -s flag is present or if no arguments
               remain commands are read from the standard input.
               Any remaining arguments specify the positional
               parameters.  Shell output (except for Special Com-
               mands) is written to file descriptor 2.
     -i        If the -i flag is present or if the shell input
               and output are attached to a terminal, this shell
               is interactive.  In this case, the TERMINATE sig-
               nal is ignored and the INTERRUPT signal is caught
               and ignored.  In all cases, the QUIT signal is
               ignored by the shell.
     -r        If the -r flag is present, the shell is a res-
               tricted shell.
     -0(zero)  If the -0(zero) flag is present, this has the same
               effect as starting the shell with the first char-
               acter of argument zero as a - (see above).

     The remaining flags and arguments are described under the
     set command above.

     Rsh Only
     Rsh is used to set up login names and execution environments
     whose capabilities are more controlled than those of the
     standard shell.  The actions of rsh are identical to those
     of sh, except that the following are disallowed:
          changing directory (see cd(1)),
          setting the value of $PATH
          specifying path or command names containing /,
          redirecting output (> and >>).

     The restrictions above are enforced after profile.sh is
     interpreted.

     When a command to be executed is found to be a shell pro-
     cedure, rsh invokes sh to execute it.  Thus, it is possible
     to provide to the end-user shell procedures that have access
     to the full power of the standard shell, while imposing a
     limited menu of commands; this scheme assumes that the end-
     user does not have write and execute permissions in the same
     directory.

     The net effect of these rules is that the writer of the
     profile.sh has complete control over user actions, by per-
     forming guaranteed setup actions and leaving the user in an
     appropriate directory (probably not the login directory).

     The system administrator often sets up a directory of com-
     mands (i.e., /usr/rbin) that can be safely invoked by rsh.
     Some systems also provide a restricted editor red.

EXIT STATUS
     Errors detected by the shell, such as syntax errors, cause
     the shell to return a non-zero exit status.  If the shell is
     being used non-interactively execution of the shell file is
     abandoned.  Otherwise, the shell returns the exit status of
     the last command executed (see also the exit command above).

FILES
     /etc/profile.sh
     $HOME/profile.sh
     $TMP/sh*

LIMIITATIONS
     Any TSR (Terminate Stay Resident) programs must be loaded
     before loading Sh as the shell will overwrite the TSR when
     it reloads itself after swapping out.

SEE ALSO
     cd(1), env(1), test(1), umask(1).
     dup(2), exec(2), pipe(2), signal(2), umask(2), wait(2), pro-
     file(4), environ(5) in the UNIX System Programmer Reference
     Manual.
